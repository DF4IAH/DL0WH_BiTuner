
DJ0ABR_Tuner_FW.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00000cae  00000d42  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000de  00800124  00800124  00000d66  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d66  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d98  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002f0  00000000  00000000  00000dd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000202f  00000000  00000000  000010c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e44  00000000  00000000  000030f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001539  00000000  00000000  00003f3b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000067c  00000000  00000000  00005474  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d2b  00000000  00000000  00005af0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000f97  00000000  00000000  0000681b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000290  00000000  00000000  000077b2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
   2:	5e c0       	rjmp	.+188    	; 0xc0 <__bad_interrupt>
   4:	5d c0       	rjmp	.+186    	; 0xc0 <__bad_interrupt>
   6:	5c c0       	rjmp	.+184    	; 0xc0 <__bad_interrupt>
   8:	5b c0       	rjmp	.+182    	; 0xc0 <__bad_interrupt>
   a:	5a c0       	rjmp	.+180    	; 0xc0 <__bad_interrupt>
   c:	59 c0       	rjmp	.+178    	; 0xc0 <__bad_interrupt>
   e:	58 c0       	rjmp	.+176    	; 0xc0 <__bad_interrupt>
  10:	57 c0       	rjmp	.+174    	; 0xc0 <__bad_interrupt>
  12:	78 c2       	rjmp	.+1264   	; 0x504 <__vector_9>
  14:	55 c0       	rjmp	.+170    	; 0xc0 <__bad_interrupt>
  16:	54 c0       	rjmp	.+168    	; 0xc0 <__bad_interrupt>
  18:	53 c0       	rjmp	.+166    	; 0xc0 <__bad_interrupt>
  1a:	52 c0       	rjmp	.+164    	; 0xc0 <__bad_interrupt>
  1c:	51 c0       	rjmp	.+162    	; 0xc0 <__bad_interrupt>
  1e:	50 c0       	rjmp	.+160    	; 0xc0 <__bad_interrupt>
  20:	5f c2       	rjmp	.+1214   	; 0x4e0 <__vector_16>
  22:	4e c0       	rjmp	.+156    	; 0xc0 <__bad_interrupt>
  24:	35 c5       	rjmp	.+2666   	; 0xa90 <__vector_18>
  26:	4c c0       	rjmp	.+152    	; 0xc0 <__bad_interrupt>
  28:	4b c0       	rjmp	.+150    	; 0xc0 <__bad_interrupt>
  2a:	4a c0       	rjmp	.+148    	; 0xc0 <__bad_interrupt>
  2c:	49 c0       	rjmp	.+146    	; 0xc0 <__bad_interrupt>
  2e:	48 c0       	rjmp	.+144    	; 0xc0 <__bad_interrupt>
  30:	0d c2       	rjmp	.+1050   	; 0x44c <__vector_24>
  32:	46 c0       	rjmp	.+140    	; 0xc0 <__bad_interrupt>
  34:	8c c2       	rjmp	.+1304   	; 0x54e <readSerialCommand+0x26>
  36:	a3 c2       	rjmp	.+1350   	; 0x57e <readSerialCommand+0x56>
  38:	c5 c2       	rjmp	.+1418   	; 0x5c4 <readSerialCommand+0x9c>
  3a:	d0 c2       	rjmp	.+1440   	; 0x5dc <readSerialCommand+0xb4>
  3c:	17 c3       	rjmp	.+1582   	; 0x66c <readSerialCommand+0x144>
  3e:	16 c3       	rjmp	.+1580   	; 0x66c <readSerialCommand+0x144>
  40:	15 c3       	rjmp	.+1578   	; 0x66c <readSerialCommand+0x144>
  42:	14 c3       	rjmp	.+1576   	; 0x66c <readSerialCommand+0x144>
  44:	13 c3       	rjmp	.+1574   	; 0x66c <readSerialCommand+0x144>
  46:	12 c3       	rjmp	.+1572   	; 0x66c <readSerialCommand+0x144>
  48:	d3 c2       	rjmp	.+1446   	; 0x5f0 <readSerialCommand+0xc8>
  4a:	e1 c2       	rjmp	.+1474   	; 0x60e <readSerialCommand+0xe6>
  4c:	f7 c2       	rjmp	.+1518   	; 0x63c <readSerialCommand+0x114>
  4e:	c4 c3       	rjmp	.+1928   	; 0x7d8 <pulserelais+0x18>
  50:	c7 c3       	rjmp	.+1934   	; 0x7e0 <pulserelais+0x20>
  52:	ca c3       	rjmp	.+1940   	; 0x7e8 <pulserelais+0x28>
  54:	cd c3       	rjmp	.+1946   	; 0x7f0 <pulserelais+0x30>
  56:	d0 c3       	rjmp	.+1952   	; 0x7f8 <pulserelais+0x38>
  58:	d3 c3       	rjmp	.+1958   	; 0x800 <pulserelais+0x40>
  5a:	d6 c3       	rjmp	.+1964   	; 0x808 <pulserelais+0x48>
  5c:	d9 c3       	rjmp	.+1970   	; 0x810 <pulserelais+0x50>
  5e:	dc c3       	rjmp	.+1976   	; 0x818 <pulserelais+0x58>
  60:	df c3       	rjmp	.+1982   	; 0x820 <pulserelais+0x60>
  62:	e2 c3       	rjmp	.+1988   	; 0x828 <pulserelais+0x68>
  64:	e5 c3       	rjmp	.+1994   	; 0x830 <pulserelais+0x70>
  66:	0e c4       	rjmp	.+2076   	; 0x884 <pulserelaisindex+0x12>
  68:	0f c4       	rjmp	.+2078   	; 0x888 <pulserelaisindex+0x16>
  6a:	10 c4       	rjmp	.+2080   	; 0x88c <pulserelaisindex+0x1a>
  6c:	11 c4       	rjmp	.+2082   	; 0x890 <pulserelaisindex+0x1e>
  6e:	12 c4       	rjmp	.+2084   	; 0x894 <pulserelaisindex+0x22>
  70:	13 c4       	rjmp	.+2086   	; 0x898 <pulserelaisindex+0x26>
  72:	14 c4       	rjmp	.+2088   	; 0x89c <pulserelaisindex+0x2a>
  74:	15 c4       	rjmp	.+2090   	; 0x8a0 <pulserelaisindex+0x2e>
  76:	16 c4       	rjmp	.+2092   	; 0x8a4 <pulserelaisindex+0x32>
  78:	17 c4       	rjmp	.+2094   	; 0x8a8 <pulserelaisindex+0x36>
  7a:	18 c4       	rjmp	.+2096   	; 0x8ac <pulserelaisindex+0x3a>
  7c:	19 c4       	rjmp	.+2098   	; 0x8b0 <pulserelaisindex+0x3e>
  7e:	1a c4       	rjmp	.+2100   	; 0x8b4 <pulserelaisindex+0x42>
  80:	1b c4       	rjmp	.+2102   	; 0x8b8 <pulserelaisindex+0x46>
  82:	1c c4       	rjmp	.+2104   	; 0x8bc <pulserelaisindex+0x4a>
  84:	1d c4       	rjmp	.+2106   	; 0x8c0 <pulserelaisindex+0x4e>
  86:	1e c4       	rjmp	.+2108   	; 0x8c4 <pulserelaisindex+0x52>
  88:	1f c4       	rjmp	.+2110   	; 0x8c8 <pulserelaisindex+0x56>

0000008a <__ctors_end>:
  8a:	11 24       	eor	r1, r1
  8c:	1f be       	out	0x3f, r1	; 63
  8e:	cf ef       	ldi	r28, 0xFF	; 255
  90:	d4 e0       	ldi	r29, 0x04	; 4
  92:	de bf       	out	0x3e, r29	; 62
  94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
  96:	11 e0       	ldi	r17, 0x01	; 1
  98:	a0 e0       	ldi	r26, 0x00	; 0
  9a:	b1 e0       	ldi	r27, 0x01	; 1
  9c:	ee ea       	ldi	r30, 0xAE	; 174
  9e:	fc e0       	ldi	r31, 0x0C	; 12
  a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
  a2:	05 90       	lpm	r0, Z+
  a4:	0d 92       	st	X+, r0
  a6:	a4 32       	cpi	r26, 0x24	; 36
  a8:	b1 07       	cpc	r27, r17
  aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
  ac:	22 e0       	ldi	r18, 0x02	; 2
  ae:	a4 e2       	ldi	r26, 0x24	; 36
  b0:	b1 e0       	ldi	r27, 0x01	; 1
  b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
  b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
  b6:	a2 30       	cpi	r26, 0x02	; 2
  b8:	b2 07       	cpc	r27, r18
  ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
  bc:	02 d0       	rcall	.+4      	; 0xc2 <main>
  be:	f5 c5       	rjmp	.+3050   	; 0xcaa <_exit>

000000c0 <__bad_interrupt>:
  c0:	9f cf       	rjmp	.-194    	; 0x0 <__vectors>

000000c2 <main>:
	while (1) {
	}
	#endif
	
	/* Call Tuner */
	tuner_main();
  c2:	5c d5       	rcall	.+2744   	; 0xb7c <tuner_main>
}
  c4:	80 e0       	ldi	r24, 0x00	; 0
  c6:	90 e0       	ldi	r25, 0x00	; 0
  c8:	08 95       	ret

000000ca <I2C_0_do_I2C_RESET>:
 * \brief Identical to I2C_0_master_operation(false);
 */
i2c_error_t I2C_0_master_write(void)
{
	return I2C_0_master_operation(false);
}
  ca:	80 e9       	ldi	r24, 0x90	; 144
  cc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__EEPROM_REGION_LENGTH__+0x7f00bc>
  d0:	e4 e2       	ldi	r30, 0x24	; 36
  d2:	f1 e0       	ldi	r31, 0x01	; 1
  d4:	80 81       	ld	r24, Z
  d6:	8e 7f       	andi	r24, 0xFE	; 254
  d8:	80 83       	st	Z, r24
  da:	13 86       	std	Z+11, r1	; 0x0b
  dc:	8e e0       	ldi	r24, 0x0E	; 14
  de:	08 95       	ret

000000e0 <I2C_0_do_I2C_IDLE>:
  e0:	e4 e2       	ldi	r30, 0x24	; 36
  e2:	f1 e0       	ldi	r31, 0x01	; 1
  e4:	80 81       	ld	r24, Z
  e6:	8e 7f       	andi	r24, 0xFE	; 254
  e8:	80 83       	st	Z, r24
  ea:	13 86       	std	Z+11, r1	; 0x0b
  ec:	80 e0       	ldi	r24, 0x00	; 0
  ee:	08 95       	ret

000000f0 <I2C_0_do_I2C_SEND_RESTART_READ>:
  f0:	ec eb       	ldi	r30, 0xBC	; 188
  f2:	f0 e0       	ldi	r31, 0x00	; 0
  f4:	80 81       	ld	r24, Z
  f6:	80 6a       	ori	r24, 0xA0	; 160
  f8:	80 83       	st	Z, r24
  fa:	81 e0       	ldi	r24, 0x01	; 1
  fc:	08 95       	ret

000000fe <I2C_0_do_I2C_SEND_RESTART_WRITE>:
  fe:	ec eb       	ldi	r30, 0xBC	; 188
 100:	f0 e0       	ldi	r31, 0x00	; 0
 102:	80 81       	ld	r24, Z
 104:	80 6a       	ori	r24, 0xA0	; 160
 106:	80 83       	st	Z, r24
 108:	82 e0       	ldi	r24, 0x02	; 2
 10a:	08 95       	ret

0000010c <I2C_0_do_I2C_SEND_RESTART>:
 10c:	ec eb       	ldi	r30, 0xBC	; 188
 10e:	f0 e0       	ldi	r31, 0x00	; 0
 110:	80 81       	ld	r24, Z
 112:	80 6a       	ori	r24, 0xA0	; 160
 114:	80 83       	st	Z, r24
 116:	81 e0       	ldi	r24, 0x01	; 1
 118:	08 95       	ret

0000011a <I2C_0_do_I2C_SEND_ADR_READ>:
 11a:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 11e:	88 7f       	andi	r24, 0xF8	; 248
 120:	88 30       	cpi	r24, 0x08	; 8
 122:	39 f0       	breq	.+14     	; 0x132 <I2C_0_do_I2C_SEND_ADR_READ+0x18>
 124:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 128:	88 7f       	andi	r24, 0xF8	; 248
 12a:	80 31       	cpi	r24, 0x10	; 16
 12c:	11 f0       	breq	.+4      	; 0x132 <I2C_0_do_I2C_SEND_ADR_READ+0x18>
 12e:	cd df       	rcall	.-102    	; 0xca <I2C_0_do_I2C_RESET>
 130:	08 95       	ret
 132:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <__data_end+0x1>
 136:	88 0f       	add	r24, r24
 138:	81 60       	ori	r24, 0x01	; 1
 13a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__EEPROM_REGION_LENGTH__+0x7f00bb>
 13e:	ec eb       	ldi	r30, 0xBC	; 188
 140:	f0 e0       	ldi	r31, 0x00	; 0
 142:	80 81       	ld	r24, Z
 144:	8f 7d       	andi	r24, 0xDF	; 223
 146:	80 83       	st	Z, r24
 148:	80 81       	ld	r24, Z
 14a:	80 68       	ori	r24, 0x80	; 128
 14c:	80 83       	st	Z, r24
 14e:	8a e0       	ldi	r24, 0x0A	; 10
 150:	08 95       	ret

00000152 <I2C_0_do_I2C_SEND_ADR_WRITE>:
 152:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 156:	88 7f       	andi	r24, 0xF8	; 248
 158:	88 30       	cpi	r24, 0x08	; 8
 15a:	39 f0       	breq	.+14     	; 0x16a <I2C_0_do_I2C_SEND_ADR_WRITE+0x18>
 15c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 160:	88 7f       	andi	r24, 0xF8	; 248
 162:	80 31       	cpi	r24, 0x10	; 16
 164:	11 f0       	breq	.+4      	; 0x16a <I2C_0_do_I2C_SEND_ADR_WRITE+0x18>
 166:	b1 df       	rcall	.-158    	; 0xca <I2C_0_do_I2C_RESET>
 168:	08 95       	ret
 16a:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <__data_end+0x1>
 16e:	88 0f       	add	r24, r24
 170:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__EEPROM_REGION_LENGTH__+0x7f00bb>
 174:	ec eb       	ldi	r30, 0xBC	; 188
 176:	f0 e0       	ldi	r31, 0x00	; 0
 178:	80 81       	ld	r24, Z
 17a:	8f 7d       	andi	r24, 0xDF	; 223
 17c:	80 83       	st	Z, r24
 17e:	80 81       	ld	r24, Z
 180:	80 68       	ori	r24, 0x80	; 128
 182:	80 83       	st	Z, r24
 184:	8b e0       	ldi	r24, 0x0B	; 11
 186:	08 95       	ret

00000188 <I2C_0_do_I2C_DO_NACK_RESTART>:
 188:	ec eb       	ldi	r30, 0xBC	; 188
 18a:	f0 e0       	ldi	r31, 0x00	; 0
 18c:	80 81       	ld	r24, Z
 18e:	80 6a       	ori	r24, 0xA0	; 160
 190:	80 83       	st	Z, r24
 192:	88 e0       	ldi	r24, 0x08	; 8
 194:	08 95       	ret

00000196 <I2C_0_do_I2C_BUS_COLLISION>:
 196:	a4 e2       	ldi	r26, 0x24	; 36
 198:	b1 e0       	ldi	r27, 0x01	; 1
 19a:	82 e0       	ldi	r24, 0x02	; 2
 19c:	1b 96       	adiw	r26, 0x0b	; 11
 19e:	8c 93       	st	X, r24
 1a0:	1b 97       	sbiw	r26, 0x0b	; 11
 1a2:	1e 96       	adiw	r26, 0x0e	; 14
 1a4:	ed 91       	ld	r30, X+
 1a6:	fc 91       	ld	r31, X
 1a8:	1f 97       	sbiw	r26, 0x0f	; 15
 1aa:	5a 96       	adiw	r26, 0x1a	; 26
 1ac:	8d 91       	ld	r24, X+
 1ae:	9c 91       	ld	r25, X
 1b0:	5b 97       	sbiw	r26, 0x1b	; 27
 1b2:	09 95       	icall
 1b4:	82 30       	cpi	r24, 0x02	; 2
 1b6:	19 f0       	breq	.+6      	; 0x1be <I2C_0_do_I2C_BUS_COLLISION+0x28>
 1b8:	83 30       	cpi	r24, 0x03	; 3
 1ba:	19 f0       	breq	.+6      	; 0x1c2 <I2C_0_do_I2C_BUS_COLLISION+0x2c>
 1bc:	04 c0       	rjmp	.+8      	; 0x1c6 <I2C_0_do_I2C_BUS_COLLISION+0x30>
 1be:	98 df       	rcall	.-208    	; 0xf0 <I2C_0_do_I2C_SEND_RESTART_READ>
 1c0:	08 95       	ret
 1c2:	9d df       	rcall	.-198    	; 0xfe <I2C_0_do_I2C_SEND_RESTART_WRITE>
 1c4:	08 95       	ret
 1c6:	81 df       	rcall	.-254    	; 0xca <I2C_0_do_I2C_RESET>
 1c8:	08 95       	ret

000001ca <I2C_0_do_I2C_BUS_ERROR>:
 1ca:	80 e9       	ldi	r24, 0x90	; 144
 1cc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__EEPROM_REGION_LENGTH__+0x7f00bc>
 1d0:	e4 e2       	ldi	r30, 0x24	; 36
 1d2:	f1 e0       	ldi	r31, 0x01	; 1
 1d4:	80 81       	ld	r24, Z
 1d6:	8e 7f       	andi	r24, 0xFE	; 254
 1d8:	80 83       	st	Z, r24
 1da:	82 e0       	ldi	r24, 0x02	; 2
 1dc:	83 87       	std	Z+11, r24	; 0x0b
 1de:	8e e0       	ldi	r24, 0x0E	; 14
 1e0:	08 95       	ret

000001e2 <I2C_0_do_I2C_DO_NACK_STOP>:
 1e2:	ec eb       	ldi	r30, 0xBC	; 188
 1e4:	f0 e0       	ldi	r31, 0x00	; 0
 1e6:	80 81       	ld	r24, Z
 1e8:	80 69       	ori	r24, 0x90	; 144
 1ea:	80 83       	st	Z, r24
 1ec:	e4 e2       	ldi	r30, 0x24	; 36
 1ee:	f1 e0       	ldi	r31, 0x01	; 1
 1f0:	80 81       	ld	r24, Z
 1f2:	8e 7f       	andi	r24, 0xFE	; 254
 1f4:	80 83       	st	Z, r24
 1f6:	13 86       	std	Z+11, r1	; 0x0b
 1f8:	80 e0       	ldi	r24, 0x00	; 0
 1fa:	08 95       	ret

000001fc <I2C_0_do_I2C_RX>:
 1fc:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 200:	88 7f       	andi	r24, 0xF8	; 248
 202:	80 35       	cpi	r24, 0x50	; 80
 204:	39 f0       	breq	.+14     	; 0x214 <I2C_0_do_I2C_RX+0x18>
 206:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 20a:	88 7f       	andi	r24, 0xF8	; 248
 20c:	88 35       	cpi	r24, 0x58	; 88
 20e:	11 f0       	breq	.+4      	; 0x214 <I2C_0_do_I2C_RX+0x18>
 210:	5c df       	rcall	.-328    	; 0xca <I2C_0_do_I2C_RESET>
 212:	08 95       	ret
 214:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <__data_end+0x4>
 218:	90 91 29 01 	lds	r25, 0x0129	; 0x800129 <__data_end+0x5>
 21c:	02 97       	sbiw	r24, 0x02	; 2
 21e:	31 f4       	brne	.+12     	; 0x22c <I2C_0_do_I2C_RX+0x30>
 220:	ec eb       	ldi	r30, 0xBC	; 188
 222:	f0 e0       	ldi	r31, 0x00	; 0
 224:	80 81       	ld	r24, Z
 226:	8f 7b       	andi	r24, 0xBF	; 191
 228:	80 83       	st	Z, r24
 22a:	05 c0       	rjmp	.+10     	; 0x236 <I2C_0_do_I2C_RX+0x3a>
 22c:	ec eb       	ldi	r30, 0xBC	; 188
 22e:	f0 e0       	ldi	r31, 0x00	; 0
 230:	80 81       	ld	r24, Z
 232:	80 64       	ori	r24, 0x40	; 64
 234:	80 83       	st	Z, r24
 236:	e4 e2       	ldi	r30, 0x24	; 36
 238:	f1 e0       	ldi	r31, 0x01	; 1
 23a:	84 81       	ldd	r24, Z+4	; 0x04
 23c:	95 81       	ldd	r25, Z+5	; 0x05
 23e:	01 97       	sbiw	r24, 0x01	; 1
 240:	95 83       	std	Z+5, r25	; 0x05
 242:	84 83       	std	Z+4, r24	; 0x04
 244:	89 2b       	or	r24, r25
 246:	89 f0       	breq	.+34     	; 0x26a <I2C_0_do_I2C_RX+0x6e>
 248:	a2 81       	ldd	r26, Z+2	; 0x02
 24a:	b3 81       	ldd	r27, Z+3	; 0x03
 24c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__EEPROM_REGION_LENGTH__+0x7f00bb>
 250:	8c 93       	st	X, r24
 252:	82 81       	ldd	r24, Z+2	; 0x02
 254:	93 81       	ldd	r25, Z+3	; 0x03
 256:	01 96       	adiw	r24, 0x01	; 1
 258:	93 83       	std	Z+3, r25	; 0x03
 25a:	82 83       	std	Z+2, r24	; 0x02
 25c:	ec eb       	ldi	r30, 0xBC	; 188
 25e:	f0 e0       	ldi	r31, 0x00	; 0
 260:	80 81       	ld	r24, Z
 262:	80 68       	ori	r24, 0x80	; 128
 264:	80 83       	st	Z, r24
 266:	84 e0       	ldi	r24, 0x04	; 4
 268:	08 95       	ret
 26a:	a4 e2       	ldi	r26, 0x24	; 36
 26c:	b1 e0       	ldi	r27, 0x01	; 1
 26e:	12 96       	adiw	r26, 0x02	; 2
 270:	ed 91       	ld	r30, X+
 272:	fc 91       	ld	r31, X
 274:	13 97       	sbiw	r26, 0x03	; 3
 276:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__EEPROM_REGION_LENGTH__+0x7f00bb>
 27a:	80 83       	st	Z, r24
 27c:	12 96       	adiw	r26, 0x02	; 2
 27e:	8d 91       	ld	r24, X+
 280:	9c 91       	ld	r25, X
 282:	13 97       	sbiw	r26, 0x03	; 3
 284:	01 96       	adiw	r24, 0x01	; 1
 286:	13 96       	adiw	r26, 0x03	; 3
 288:	9c 93       	st	X, r25
 28a:	8e 93       	st	-X, r24
 28c:	12 97       	sbiw	r26, 0x02	; 2
 28e:	8c 91       	ld	r24, X
 290:	84 60       	ori	r24, 0x04	; 4
 292:	8c 93       	st	X, r24
 294:	1c 96       	adiw	r26, 0x0c	; 12
 296:	ed 91       	ld	r30, X+
 298:	fc 91       	ld	r31, X
 29a:	1d 97       	sbiw	r26, 0x0d	; 13
 29c:	58 96       	adiw	r26, 0x18	; 24
 29e:	8d 91       	ld	r24, X+
 2a0:	9c 91       	ld	r25, X
 2a2:	59 97       	sbiw	r26, 0x19	; 25
 2a4:	09 95       	icall
 2a6:	82 50       	subi	r24, 0x02	; 2
 2a8:	82 30       	cpi	r24, 0x02	; 2
 2aa:	10 f4       	brcc	.+4      	; 0x2b0 <I2C_0_do_I2C_RX+0xb4>
 2ac:	6d df       	rcall	.-294    	; 0x188 <I2C_0_do_I2C_DO_NACK_RESTART>
 2ae:	08 95       	ret
 2b0:	98 df       	rcall	.-208    	; 0x1e2 <I2C_0_do_I2C_DO_NACK_STOP>
 2b2:	08 95       	ret

000002b4 <I2C_0_do_I2C_SEND_STOP>:
 2b4:	ec eb       	ldi	r30, 0xBC	; 188
 2b6:	f0 e0       	ldi	r31, 0x00	; 0
 2b8:	80 81       	ld	r24, Z
 2ba:	80 69       	ori	r24, 0x90	; 144
 2bc:	80 83       	st	Z, r24
 2be:	e4 e2       	ldi	r30, 0x24	; 36
 2c0:	f1 e0       	ldi	r31, 0x01	; 1
 2c2:	80 81       	ld	r24, Z
 2c4:	8e 7f       	andi	r24, 0xFE	; 254
 2c6:	80 83       	st	Z, r24
 2c8:	13 86       	std	Z+11, r1	; 0x0b
 2ca:	80 e0       	ldi	r24, 0x00	; 0
 2cc:	08 95       	ret

000002ce <I2C_0_do_I2C_DO_ADDRESS_NACK>:
 2ce:	a4 e2       	ldi	r26, 0x24	; 36
 2d0:	b1 e0       	ldi	r27, 0x01	; 1
 2d2:	82 e0       	ldi	r24, 0x02	; 2
 2d4:	1b 96       	adiw	r26, 0x0b	; 11
 2d6:	8c 93       	st	X, r24
 2d8:	1b 97       	sbiw	r26, 0x0b	; 11
 2da:	50 96       	adiw	r26, 0x10	; 16
 2dc:	ed 91       	ld	r30, X+
 2de:	fc 91       	ld	r31, X
 2e0:	51 97       	sbiw	r26, 0x11	; 17
 2e2:	5c 96       	adiw	r26, 0x1c	; 28
 2e4:	8d 91       	ld	r24, X+
 2e6:	9c 91       	ld	r25, X
 2e8:	5d 97       	sbiw	r26, 0x1d	; 29
 2ea:	09 95       	icall
 2ec:	82 30       	cpi	r24, 0x02	; 2
 2ee:	19 f0       	breq	.+6      	; 0x2f6 <I2C_0_do_I2C_DO_ADDRESS_NACK+0x28>
 2f0:	83 30       	cpi	r24, 0x03	; 3
 2f2:	19 f0       	breq	.+6      	; 0x2fa <I2C_0_do_I2C_DO_ADDRESS_NACK+0x2c>
 2f4:	04 c0       	rjmp	.+8      	; 0x2fe <I2C_0_do_I2C_DO_ADDRESS_NACK+0x30>
 2f6:	fc de       	rcall	.-520    	; 0xf0 <I2C_0_do_I2C_SEND_RESTART_READ>
 2f8:	08 95       	ret
 2fa:	01 df       	rcall	.-510    	; 0xfe <I2C_0_do_I2C_SEND_RESTART_WRITE>
 2fc:	08 95       	ret
 2fe:	da df       	rcall	.-76     	; 0x2b4 <I2C_0_do_I2C_SEND_STOP>
 300:	08 95       	ret

00000302 <I2C_0_do_I2C_RX_DO_ACK>:
 302:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 306:	88 7f       	andi	r24, 0xF8	; 248
 308:	80 34       	cpi	r24, 0x40	; 64
 30a:	11 f0       	breq	.+4      	; 0x310 <I2C_0_do_I2C_RX_DO_ACK+0xe>
 30c:	e0 df       	rcall	.-64     	; 0x2ce <I2C_0_do_I2C_DO_ADDRESS_NACK>
 30e:	08 95       	ret
 310:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <__data_end+0x4>
 314:	90 91 29 01 	lds	r25, 0x0129	; 0x800129 <__data_end+0x5>
 318:	01 97       	sbiw	r24, 0x01	; 1
 31a:	39 f4       	brne	.+14     	; 0x32a <I2C_0_do_I2C_RX_DO_ACK+0x28>
 31c:	ec eb       	ldi	r30, 0xBC	; 188
 31e:	f0 e0       	ldi	r31, 0x00	; 0
 320:	80 81       	ld	r24, Z
 322:	8f 7b       	andi	r24, 0xBF	; 191
 324:	80 83       	st	Z, r24
 326:	84 e0       	ldi	r24, 0x04	; 4
 328:	08 95       	ret
 32a:	ec eb       	ldi	r30, 0xBC	; 188
 32c:	f0 e0       	ldi	r31, 0x00	; 0
 32e:	80 81       	ld	r24, Z
 330:	80 64       	ori	r24, 0x40	; 64
 332:	80 83       	st	Z, r24
 334:	84 e0       	ldi	r24, 0x04	; 4
 336:	08 95       	ret

00000338 <I2C_0_do_I2C_TX_DO_ACK>:
 338:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 33c:	88 7f       	andi	r24, 0xF8	; 248
 33e:	88 31       	cpi	r24, 0x18	; 24
 340:	11 f0       	breq	.+4      	; 0x346 <I2C_0_do_I2C_TX_DO_ACK+0xe>
 342:	c5 df       	rcall	.-118    	; 0x2ce <I2C_0_do_I2C_DO_ADDRESS_NACK>
 344:	08 95       	ret
 346:	83 e0       	ldi	r24, 0x03	; 3
 348:	08 95       	ret

0000034a <I2C_0_do_I2C_TX>:
 34a:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 34e:	88 7f       	andi	r24, 0xF8	; 248
 350:	80 33       	cpi	r24, 0x30	; 48
 352:	51 f0       	breq	.+20     	; 0x368 <I2C_0_do_I2C_TX+0x1e>
 354:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 358:	88 7f       	andi	r24, 0xF8	; 248
 35a:	88 34       	cpi	r24, 0x48	; 72
 35c:	29 f0       	breq	.+10     	; 0x368 <I2C_0_do_I2C_TX+0x1e>
 35e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 362:	88 7f       	andi	r24, 0xF8	; 248
 364:	80 32       	cpi	r24, 0x20	; 32
 366:	b1 f4       	brne	.+44     	; 0x394 <I2C_0_do_I2C_TX+0x4a>
 368:	a4 e2       	ldi	r26, 0x24	; 36
 36a:	b1 e0       	ldi	r27, 0x01	; 1
 36c:	52 96       	adiw	r26, 0x12	; 18
 36e:	ed 91       	ld	r30, X+
 370:	fc 91       	ld	r31, X
 372:	53 97       	sbiw	r26, 0x13	; 19
 374:	5e 96       	adiw	r26, 0x1e	; 30
 376:	8d 91       	ld	r24, X+
 378:	9c 91       	ld	r25, X
 37a:	5f 97       	sbiw	r26, 0x1f	; 31
 37c:	09 95       	icall
 37e:	82 30       	cpi	r24, 0x02	; 2
 380:	19 f0       	breq	.+6      	; 0x388 <I2C_0_do_I2C_TX+0x3e>
 382:	83 30       	cpi	r24, 0x03	; 3
 384:	19 f0       	breq	.+6      	; 0x38c <I2C_0_do_I2C_TX+0x42>
 386:	04 c0       	rjmp	.+8      	; 0x390 <I2C_0_do_I2C_TX+0x46>
 388:	b3 de       	rcall	.-666    	; 0xf0 <I2C_0_do_I2C_SEND_RESTART_READ>
 38a:	08 95       	ret
 38c:	b8 de       	rcall	.-656    	; 0xfe <I2C_0_do_I2C_SEND_RESTART_WRITE>
 38e:	08 95       	ret
 390:	91 df       	rcall	.-222    	; 0x2b4 <I2C_0_do_I2C_SEND_STOP>
 392:	08 95       	ret
 394:	e4 e2       	ldi	r30, 0x24	; 36
 396:	f1 e0       	ldi	r31, 0x01	; 1
 398:	a2 81       	ldd	r26, Z+2	; 0x02
 39a:	b3 81       	ldd	r27, Z+3	; 0x03
 39c:	cd 01       	movw	r24, r26
 39e:	01 96       	adiw	r24, 0x01	; 1
 3a0:	93 83       	std	Z+3, r25	; 0x03
 3a2:	82 83       	std	Z+2, r24	; 0x02
 3a4:	8c 91       	ld	r24, X
 3a6:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__EEPROM_REGION_LENGTH__+0x7f00bb>
 3aa:	ac eb       	ldi	r26, 0xBC	; 188
 3ac:	b0 e0       	ldi	r27, 0x00	; 0
 3ae:	8c 91       	ld	r24, X
 3b0:	80 68       	ori	r24, 0x80	; 128
 3b2:	8c 93       	st	X, r24
 3b4:	84 81       	ldd	r24, Z+4	; 0x04
 3b6:	95 81       	ldd	r25, Z+5	; 0x05
 3b8:	01 97       	sbiw	r24, 0x01	; 1
 3ba:	95 83       	std	Z+5, r25	; 0x05
 3bc:	84 83       	std	Z+4, r24	; 0x04
 3be:	89 2b       	or	r24, r25
 3c0:	11 f4       	brne	.+4      	; 0x3c6 <I2C_0_do_I2C_TX+0x7c>
 3c2:	85 e0       	ldi	r24, 0x05	; 5
 3c4:	08 95       	ret
 3c6:	83 e0       	ldi	r24, 0x03	; 3
 3c8:	08 95       	ret

000003ca <I2C_0_do_I2C_TX_EMPTY>:
 3ca:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 3ce:	88 7f       	andi	r24, 0xF8	; 248
 3d0:	80 33       	cpi	r24, 0x30	; 48
 3d2:	51 f0       	breq	.+20     	; 0x3e8 <I2C_0_do_I2C_TX_EMPTY+0x1e>
 3d4:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 3d8:	88 7f       	andi	r24, 0xF8	; 248
 3da:	88 34       	cpi	r24, 0x48	; 72
 3dc:	29 f0       	breq	.+10     	; 0x3e8 <I2C_0_do_I2C_TX_EMPTY+0x1e>
 3de:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 3e2:	88 7f       	andi	r24, 0xF8	; 248
 3e4:	80 32       	cpi	r24, 0x20	; 32
 3e6:	b1 f4       	brne	.+44     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
 3e8:	a4 e2       	ldi	r26, 0x24	; 36
 3ea:	b1 e0       	ldi	r27, 0x01	; 1
 3ec:	52 96       	adiw	r26, 0x12	; 18
 3ee:	ed 91       	ld	r30, X+
 3f0:	fc 91       	ld	r31, X
 3f2:	53 97       	sbiw	r26, 0x13	; 19
 3f4:	5e 96       	adiw	r26, 0x1e	; 30
 3f6:	8d 91       	ld	r24, X+
 3f8:	9c 91       	ld	r25, X
 3fa:	5f 97       	sbiw	r26, 0x1f	; 31
 3fc:	09 95       	icall
 3fe:	82 30       	cpi	r24, 0x02	; 2
 400:	19 f0       	breq	.+6      	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
 402:	83 30       	cpi	r24, 0x03	; 3
 404:	19 f0       	breq	.+6      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
 406:	04 c0       	rjmp	.+8      	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
 408:	73 de       	rcall	.-794    	; 0xf0 <I2C_0_do_I2C_SEND_RESTART_READ>
 40a:	08 95       	ret
 40c:	78 de       	rcall	.-784    	; 0xfe <I2C_0_do_I2C_SEND_RESTART_WRITE>
 40e:	08 95       	ret
 410:	51 df       	rcall	.-350    	; 0x2b4 <I2C_0_do_I2C_SEND_STOP>
 412:	08 95       	ret
 414:	a4 e2       	ldi	r26, 0x24	; 36
 416:	b1 e0       	ldi	r27, 0x01	; 1
 418:	8c 91       	ld	r24, X
 41a:	84 60       	ori	r24, 0x04	; 4
 41c:	8c 93       	st	X, r24
 41e:	1c 96       	adiw	r26, 0x0c	; 12
 420:	ed 91       	ld	r30, X+
 422:	fc 91       	ld	r31, X
 424:	1d 97       	sbiw	r26, 0x0d	; 13
 426:	58 96       	adiw	r26, 0x18	; 24
 428:	8d 91       	ld	r24, X+
 42a:	9c 91       	ld	r25, X
 42c:	59 97       	sbiw	r26, 0x19	; 25
 42e:	09 95       	icall
 430:	83 30       	cpi	r24, 0x03	; 3
 432:	31 f0       	breq	.+12     	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
 434:	84 30       	cpi	r24, 0x04	; 4
 436:	31 f0       	breq	.+12     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
 438:	82 30       	cpi	r24, 0x02	; 2
 43a:	31 f4       	brne	.+12     	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
 43c:	59 de       	rcall	.-846    	; 0xf0 <I2C_0_do_I2C_SEND_RESTART_READ>
 43e:	08 95       	ret
 440:	5e de       	rcall	.-836    	; 0xfe <I2C_0_do_I2C_SEND_RESTART_WRITE>
 442:	08 95       	ret
 444:	82 df       	rcall	.-252    	; 0x34a <I2C_0_do_I2C_TX>
 446:	08 95       	ret
 448:	35 df       	rcall	.-406    	; 0x2b4 <I2C_0_do_I2C_SEND_STOP>
 44a:	08 95       	ret

0000044c <__vector_24>:
    I2C_0_do_I2C_BUS_COLLISION,      // I2C_BUS_COLLISION
    I2C_0_do_I2C_BUS_ERROR           // I2C_BUS_ERROR
};

ISR(TWI_vect)
{
 44c:	1f 92       	push	r1
 44e:	0f 92       	push	r0
 450:	0f b6       	in	r0, 0x3f	; 63
 452:	0f 92       	push	r0
 454:	11 24       	eor	r1, r1
 456:	2f 93       	push	r18
 458:	3f 93       	push	r19
 45a:	4f 93       	push	r20
 45c:	5f 93       	push	r21
 45e:	6f 93       	push	r22
 460:	7f 93       	push	r23
 462:	8f 93       	push	r24
 464:	9f 93       	push	r25
 466:	af 93       	push	r26
 468:	bf 93       	push	r27
 46a:	cf 93       	push	r28
 46c:	df 93       	push	r29
 46e:	ef 93       	push	r30
 470:	ff 93       	push	r31
{

	// NOTE: We are ignoring the Write Collision flag.

	// Bus arbitration lost to another master, override next state
	if (((TWSR & 0xF8) == 0x38) || ((TWSR & 0xF8) == 0x68) || ((TWSR & 0xF8) == 0x78) || ((TWSR & 0xF8) == 0xB0)) {
 472:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 476:	88 7f       	andi	r24, 0xF8	; 248
 478:	88 33       	cpi	r24, 0x38	; 56
 47a:	79 f0       	breq	.+30     	; 0x49a <__vector_24+0x4e>
 47c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 480:	88 7f       	andi	r24, 0xF8	; 248
 482:	88 36       	cpi	r24, 0x68	; 104
 484:	51 f0       	breq	.+20     	; 0x49a <__vector_24+0x4e>
 486:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 48a:	88 7f       	andi	r24, 0xF8	; 248
 48c:	88 37       	cpi	r24, 0x78	; 120
 48e:	29 f0       	breq	.+10     	; 0x49a <__vector_24+0x4e>
 490:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__EEPROM_REGION_LENGTH__+0x7f00b9>
 494:	88 7f       	andi	r24, 0xF8	; 248
 496:	80 3b       	cpi	r24, 0xB0	; 176
 498:	19 f4       	brne	.+6      	; 0x4a0 <__vector_24+0x54>
		I2C_0_status.state = I2C_BUS_COLLISION; // State Override
 49a:	80 e1       	ldi	r24, 0x10	; 16
 49c:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0xa>
	}

	I2C_0_status.state = I2C_0_fsmStateTable[I2C_0_status.state]();
 4a0:	c4 e2       	ldi	r28, 0x24	; 36
 4a2:	d1 e0       	ldi	r29, 0x01	; 1
 4a4:	ea 85       	ldd	r30, Y+10	; 0x0a
 4a6:	f0 e0       	ldi	r31, 0x00	; 0
 4a8:	ee 0f       	add	r30, r30
 4aa:	ff 1f       	adc	r31, r31
 4ac:	e0 50       	subi	r30, 0x00	; 0
 4ae:	ff 4f       	sbci	r31, 0xFF	; 255
 4b0:	01 90       	ld	r0, Z+
 4b2:	f0 81       	ld	r31, Z
 4b4:	e0 2d       	mov	r30, r0
 4b6:	09 95       	icall
 4b8:	8a 87       	std	Y+10, r24	; 0x0a
};

ISR(TWI_vect)
{
	I2C_0_master_isr();
}
 4ba:	ff 91       	pop	r31
 4bc:	ef 91       	pop	r30
 4be:	df 91       	pop	r29
 4c0:	cf 91       	pop	r28
 4c2:	bf 91       	pop	r27
 4c4:	af 91       	pop	r26
 4c6:	9f 91       	pop	r25
 4c8:	8f 91       	pop	r24
 4ca:	7f 91       	pop	r23
 4cc:	6f 91       	pop	r22
 4ce:	5f 91       	pop	r21
 4d0:	4f 91       	pop	r20
 4d2:	3f 91       	pop	r19
 4d4:	2f 91       	pop	r18
 4d6:	0f 90       	pop	r0
 4d8:	0f be       	out	0x3f, r0	; 63
 4da:	0f 90       	pop	r0
 4dc:	1f 90       	pop	r1
 4de:	18 95       	reti

000004e0 <__vector_16>:
 *
 * \return Nothing.
 */
void PWM_1_register_callback(pwm_irq_cb_t f)
{
	PWM_1_cb = f;
 4e0:	1f 92       	push	r1
 4e2:	0f 92       	push	r0
 4e4:	0f b6       	in	r0, 0x3f	; 63
 4e6:	0f 92       	push	r0
 4e8:	11 24       	eor	r1, r1
 4ea:	8f 93       	push	r24
 4ec:	a8 9a       	sbi	0x15, 0	; 21
 4ee:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <callback_count.1850>
 4f2:	8f 5f       	subi	r24, 0xFF	; 255
 4f4:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <callback_count.1850>
 4f8:	8f 91       	pop	r24
 4fa:	0f 90       	pop	r0
 4fc:	0f be       	out	0x3f, r0	; 63
 4fe:	0f 90       	pop	r0
 500:	1f 90       	pop	r1
 502:	18 95       	reti

00000504 <__vector_9>:
}

ISR(TIMER2_OVF_vect)
{
 504:	1f 92       	push	r1
 506:	0f 92       	push	r0
 508:	0f b6       	in	r0, 0x3f	; 63
 50a:	0f 92       	push	r0
 50c:	11 24       	eor	r1, r1
 50e:	8f 93       	push	r24
	static volatile uint8_t callback_count = 0;

	// Clear the interrupt flag
	TIFR2 |= (1 << TOV2);
 510:	b8 9a       	sbi	0x17, 0	; 23

	// callback function - called every 0 passes
	if ((++callback_count >= PWM_1_INTERRUPT_CB_RATE) && (PWM_1_INTERRUPT_CB_RATE != 0)) {
 512:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <callback_count.1883>
 516:	8f 5f       	subi	r24, 0xFF	; 255
 518:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <callback_count.1883>
		if (PWM_1_cb != NULL) {
			PWM_1_cb();
		}
	}
}
 51c:	8f 91       	pop	r24
 51e:	0f 90       	pop	r0
 520:	0f be       	out	0x3f, r0	; 63
 522:	0f 90       	pop	r0
 524:	1f 90       	pop	r1
 526:	18 95       	reti

00000528 <readSerialCommand>:

unsigned long shortval = 0;
char shortvalid = 0;

void readSerialCommand()
{
 528:	0f 93       	push	r16
 52a:	1f 93       	push	r17
static char status = 0;
char c;
unsigned long ul;

    if(dataAvailable() == 0) return;    // nichts zu tun
 52c:	fe d2       	rcall	.+1532   	; 0xb2a <dataAvailable>
 52e:	88 23       	and	r24, r24
 530:	09 f4       	brne	.+2      	; 0x534 <readSerialCommand+0xc>
 532:	9c c0       	rjmp	.+312    	; 0x66c <readSerialCommand+0x144>
    c = tuner_getchar();
 534:	fd d2       	rcall	.+1530   	; 0xb30 <tuner_getchar>
	// Bit 0..7 = C0..7
	// Bit 8..15 = L0..7
	// Bit 16 = V
	// Bit 17 = H

	switch(status)
 536:	e0 91 4a 01 	lds	r30, 0x014A	; 0x80014a <status.1756>
 53a:	4e 2f       	mov	r20, r30
 53c:	50 e0       	ldi	r21, 0x00	; 0
 53e:	4d 30       	cpi	r20, 0x0D	; 13
 540:	51 05       	cpc	r21, r1
 542:	08 f0       	brcs	.+2      	; 0x546 <readSerialCommand+0x1e>
 544:	93 c0       	rjmp	.+294    	; 0x66c <readSerialCommand+0x144>
 546:	fa 01       	movw	r30, r20
 548:	e6 5e       	subi	r30, 0xE6	; 230
 54a:	ff 4f       	sbci	r31, 0xFF	; 255
 54c:	09 94       	ijmp
	{
		case 0:
				// erlaubte Bytes: L, C, V oder R, alles andere ignorieren
				c &= ~0x20; // wandle in Großbuchstaben
 54e:	98 2f       	mov	r25, r24
 550:	9f 7d       	andi	r25, 0xDF	; 223
				if(c == 'L' || c == 'C' || c == 'V' || c == 'H')
 552:	93 34       	cpi	r25, 0x43	; 67
 554:	29 f0       	breq	.+10     	; 0x560 <readSerialCommand+0x38>
 556:	96 35       	cpi	r25, 0x56	; 86
 558:	19 f0       	breq	.+6      	; 0x560 <readSerialCommand+0x38>
 55a:	8b 7d       	andi	r24, 0xDB	; 219
 55c:	88 34       	cpi	r24, 0x48	; 72
 55e:	29 f4       	brne	.+10     	; 0x56a <readSerialCommand+0x42>
				{
					command = c;
 560:	90 93 79 01 	sts	0x0179, r25	; 0x800179 <command>
					status = 1;
 564:	81 e0       	ldi	r24, 0x01	; 1
 566:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <status.1756>
				}

				// Kurzformat
				if( c == 'K')
 56a:	9b 34       	cpi	r25, 0x4B	; 75
 56c:	09 f0       	breq	.+2      	; 0x570 <readSerialCommand+0x48>
 56e:	7e c0       	rjmp	.+252    	; 0x66c <readSerialCommand+0x144>
				{
					command = c;
 570:	8b e4       	ldi	r24, 0x4B	; 75
 572:	80 93 79 01 	sts	0x0179, r24	; 0x800179 <command>
					status = 10;
 576:	8a e0       	ldi	r24, 0x0A	; 10
 578:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <status.1756>
 57c:	77 c0       	rjmp	.+238    	; 0x66c <readSerialCommand+0x144>
				}
				break;
    
		case 1:
				// erlaubte Werte L/C: 1-8 oder V/R: cr oder lf
				if(command == 'L' || command == 'C')
 57e:	90 91 79 01 	lds	r25, 0x0179	; 0x800179 <command>
 582:	9c 34       	cpi	r25, 0x4C	; 76
 584:	11 f0       	breq	.+4      	; 0x58a <readSerialCommand+0x62>
 586:	93 34       	cpi	r25, 0x43	; 67
 588:	61 f4       	brne	.+24     	; 0x5a2 <readSerialCommand+0x7a>
				{
					if(c>='1' && c<='8')
 58a:	81 53       	subi	r24, 0x31	; 49
 58c:	88 30       	cpi	r24, 0x08	; 8
 58e:	30 f4       	brcc	.+12     	; 0x59c <readSerialCommand+0x74>
					{
						parameter = c - 0x30 -1;
 590:	80 93 78 01 	sts	0x0178, r24	; 0x800178 <parameter>
						status = 2;
 594:	82 e0       	ldi	r24, 0x02	; 2
 596:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <status.1756>
 59a:	68 c0       	rjmp	.+208    	; 0x66c <readSerialCommand+0x144>
					}
					else
						status = 0;
 59c:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <status.1756>
 5a0:	65 c0       	rjmp	.+202    	; 0x66c <readSerialCommand+0x144>
				}
				else if(command == 'V' || command == 'H')
 5a2:	96 35       	cpi	r25, 0x56	; 86
 5a4:	11 f0       	breq	.+4      	; 0x5aa <readSerialCommand+0x82>
 5a6:	98 34       	cpi	r25, 0x48	; 72
 5a8:	51 f4       	brne	.+20     	; 0x5be <readSerialCommand+0x96>
				{
					if(c == '0' || c == '1') 
 5aa:	80 53       	subi	r24, 0x30	; 48
 5ac:	82 30       	cpi	r24, 0x02	; 2
 5ae:	08 f0       	brcs	.+2      	; 0x5b2 <readSerialCommand+0x8a>
 5b0:	5d c0       	rjmp	.+186    	; 0x66c <readSerialCommand+0x144>
					{                
						action = c - 0x30;
 5b2:	80 93 7a 01 	sts	0x017A, r24	; 0x80017a <action>
						status = 3;
 5b6:	83 e0       	ldi	r24, 0x03	; 3
 5b8:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <status.1756>
 5bc:	57 c0       	rjmp	.+174    	; 0x66c <readSerialCommand+0x144>
					}
				}
				else
					status = 0;
 5be:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <status.1756>
 5c2:	54 c0       	rjmp	.+168    	; 0x66c <readSerialCommand+0x144>
				break;
    
		case 2:
				if(c == '0' || c == '1')
 5c4:	80 53       	subi	r24, 0x30	; 48
 5c6:	82 30       	cpi	r24, 0x02	; 2
 5c8:	30 f4       	brcc	.+12     	; 0x5d6 <readSerialCommand+0xae>
				{
					action = c - 0x30;
 5ca:	80 93 7a 01 	sts	0x017A, r24	; 0x80017a <action>
					status = 3;
 5ce:	83 e0       	ldi	r24, 0x03	; 3
 5d0:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <status.1756>
 5d4:	4b c0       	rjmp	.+150    	; 0x66c <readSerialCommand+0x144>
				} 
				else
					status = 0;
 5d6:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <status.1756>
 5da:	48 c0       	rjmp	.+144    	; 0x66c <readSerialCommand+0x144>
				break;
    
		case 3:
				// cr oder lf Abschluss von L oder C Kommando
				if(c == '\r' || c == '\n')
 5dc:	8d 30       	cpi	r24, 0x0D	; 13
 5de:	11 f0       	breq	.+4      	; 0x5e4 <readSerialCommand+0xbc>
 5e0:	8a 30       	cpi	r24, 0x0A	; 10
 5e2:	19 f4       	brne	.+6      	; 0x5ea <readSerialCommand+0xc2>
					valid = 1;
 5e4:	81 e0       	ldi	r24, 0x01	; 1
 5e6:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <valid>
            
				status = 0;
 5ea:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <status.1756>
				break;   
 5ee:	3e c0       	rjmp	.+124    	; 0x66c <readSerialCommand+0x144>
	
		case 10: 
				shortval = c;
 5f0:	90 e0       	ldi	r25, 0x00	; 0
 5f2:	a0 e0       	ldi	r26, 0x00	; 0
 5f4:	b0 e0       	ldi	r27, 0x00	; 0
 5f6:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <shortval>
 5fa:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <shortval+0x1>
 5fe:	a0 93 4e 01 	sts	0x014E, r26	; 0x80014e <shortval+0x2>
 602:	b0 93 4f 01 	sts	0x014F, r27	; 0x80014f <shortval+0x3>
				status ++;
 606:	8b e0       	ldi	r24, 0x0B	; 11
 608:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <status.1756>
				break;
 60c:	2f c0       	rjmp	.+94     	; 0x66c <readSerialCommand+0x144>

		case 11:
				ul = c;
				ul <<= 8;
				shortval |= ul;
 60e:	40 91 4c 01 	lds	r20, 0x014C	; 0x80014c <shortval>
 612:	50 91 4d 01 	lds	r21, 0x014D	; 0x80014d <shortval+0x1>
 616:	60 91 4e 01 	lds	r22, 0x014E	; 0x80014e <shortval+0x2>
 61a:	70 91 4f 01 	lds	r23, 0x014F	; 0x80014f <shortval+0x3>
 61e:	8a 01       	movw	r16, r20
 620:	9b 01       	movw	r18, r22
 622:	18 2b       	or	r17, r24
 624:	00 93 4c 01 	sts	0x014C, r16	; 0x80014c <shortval>
 628:	10 93 4d 01 	sts	0x014D, r17	; 0x80014d <shortval+0x1>
 62c:	20 93 4e 01 	sts	0x014E, r18	; 0x80014e <shortval+0x2>
 630:	30 93 4f 01 	sts	0x014F, r19	; 0x80014f <shortval+0x3>
				status++;
 634:	8c e0       	ldi	r24, 0x0C	; 12
 636:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <status.1756>
				break;
 63a:	18 c0       	rjmp	.+48     	; 0x66c <readSerialCommand+0x144>

		case 12:
				ul = c;
				ul <<= 16;
				shortval |= ul;
 63c:	40 91 4c 01 	lds	r20, 0x014C	; 0x80014c <shortval>
 640:	50 91 4d 01 	lds	r21, 0x014D	; 0x80014d <shortval+0x1>
 644:	60 91 4e 01 	lds	r22, 0x014E	; 0x80014e <shortval+0x2>
 648:	70 91 4f 01 	lds	r23, 0x014F	; 0x80014f <shortval+0x3>
 64c:	8a 01       	movw	r16, r20
 64e:	9b 01       	movw	r18, r22
 650:	28 2b       	or	r18, r24
 652:	00 93 4c 01 	sts	0x014C, r16	; 0x80014c <shortval>
 656:	10 93 4d 01 	sts	0x014D, r17	; 0x80014d <shortval+0x1>
 65a:	20 93 4e 01 	sts	0x014E, r18	; 0x80014e <shortval+0x2>
 65e:	30 93 4f 01 	sts	0x014F, r19	; 0x80014f <shortval+0x3>
				shortvalid = 1;
 662:	81 e0       	ldi	r24, 0x01	; 1
 664:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <shortvalid>
				status=0;
 668:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <status.1756>
				break;
	}   
}
 66c:	1f 91       	pop	r17
 66e:	0f 91       	pop	r16
 670:	08 95       	ret

00000672 <pulsedirectport>:
char relais[18] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
char oldrelais[18] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

void pulsedirectport(char port, unsigned char portnum)
{
    if(port == 'B')
 672:	82 34       	cpi	r24, 0x42	; 66
 674:	b1 f4       	brne	.+44     	; 0x6a2 <pulsedirectport+0x30>
    {
        PORTB = PORTB | (1<<portnum);
 676:	25 b1       	in	r18, 0x05	; 5
 678:	81 e0       	ldi	r24, 0x01	; 1
 67a:	90 e0       	ldi	r25, 0x00	; 0
 67c:	02 c0       	rjmp	.+4      	; 0x682 <pulsedirectport+0x10>
 67e:	88 0f       	add	r24, r24
 680:	99 1f       	adc	r25, r25
 682:	6a 95       	dec	r22
 684:	e2 f7       	brpl	.-8      	; 0x67e <pulsedirectport+0xc>
 686:	92 2f       	mov	r25, r18
 688:	98 2b       	or	r25, r24
 68a:	95 b9       	out	0x05, r25	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 68c:	ef e3       	ldi	r30, 0x3F	; 63
 68e:	fc e9       	ldi	r31, 0x9C	; 156
 690:	31 97       	sbiw	r30, 0x01	; 1
 692:	f1 f7       	brne	.-4      	; 0x690 <pulsedirectport+0x1e>
 694:	00 c0       	rjmp	.+0      	; 0x696 <pulsedirectport+0x24>
 696:	00 00       	nop
        _delay_ms(20);
        PORTB = PORTB & ~(1<<portnum);
 698:	95 b1       	in	r25, 0x05	; 5
 69a:	80 95       	com	r24
 69c:	89 23       	and	r24, r25
 69e:	85 b9       	out	0x05, r24	; 5
        return;
 6a0:	08 95       	ret
    }
    
    if(port == 'C')
 6a2:	83 34       	cpi	r24, 0x43	; 67
 6a4:	b1 f4       	brne	.+44     	; 0x6d2 <pulsedirectport+0x60>
    {
        PORTC = PORTC | (1<<portnum);
 6a6:	28 b1       	in	r18, 0x08	; 8
 6a8:	81 e0       	ldi	r24, 0x01	; 1
 6aa:	90 e0       	ldi	r25, 0x00	; 0
 6ac:	02 c0       	rjmp	.+4      	; 0x6b2 <pulsedirectport+0x40>
 6ae:	88 0f       	add	r24, r24
 6b0:	99 1f       	adc	r25, r25
 6b2:	6a 95       	dec	r22
 6b4:	e2 f7       	brpl	.-8      	; 0x6ae <pulsedirectport+0x3c>
 6b6:	92 2f       	mov	r25, r18
 6b8:	98 2b       	or	r25, r24
 6ba:	98 b9       	out	0x08, r25	; 8
 6bc:	ef e3       	ldi	r30, 0x3F	; 63
 6be:	fc e9       	ldi	r31, 0x9C	; 156
 6c0:	31 97       	sbiw	r30, 0x01	; 1
 6c2:	f1 f7       	brne	.-4      	; 0x6c0 <pulsedirectport+0x4e>
 6c4:	00 c0       	rjmp	.+0      	; 0x6c6 <pulsedirectport+0x54>
 6c6:	00 00       	nop
        _delay_ms(20);
        PORTC = PORTC & ~(1<<portnum);
 6c8:	98 b1       	in	r25, 0x08	; 8
 6ca:	80 95       	com	r24
 6cc:	89 23       	and	r24, r25
 6ce:	88 b9       	out	0x08, r24	; 8
        return;
 6d0:	08 95       	ret
    }
    
    if(port == 'D')
 6d2:	84 34       	cpi	r24, 0x44	; 68
 6d4:	a9 f4       	brne	.+42     	; 0x700 <pulsedirectport+0x8e>
    {
        PORTD = PORTD | (1<<portnum);
 6d6:	2b b1       	in	r18, 0x0b	; 11
 6d8:	81 e0       	ldi	r24, 0x01	; 1
 6da:	90 e0       	ldi	r25, 0x00	; 0
 6dc:	02 c0       	rjmp	.+4      	; 0x6e2 <pulsedirectport+0x70>
 6de:	88 0f       	add	r24, r24
 6e0:	99 1f       	adc	r25, r25
 6e2:	6a 95       	dec	r22
 6e4:	e2 f7       	brpl	.-8      	; 0x6de <pulsedirectport+0x6c>
 6e6:	92 2f       	mov	r25, r18
 6e8:	98 2b       	or	r25, r24
 6ea:	9b b9       	out	0x0b, r25	; 11
 6ec:	ef e3       	ldi	r30, 0x3F	; 63
 6ee:	fc e9       	ldi	r31, 0x9C	; 156
 6f0:	31 97       	sbiw	r30, 0x01	; 1
 6f2:	f1 f7       	brne	.-4      	; 0x6f0 <pulsedirectport+0x7e>
 6f4:	00 c0       	rjmp	.+0      	; 0x6f6 <pulsedirectport+0x84>
 6f6:	00 00       	nop
        _delay_ms(20);
        PORTD = PORTD & ~(1<<portnum);
 6f8:	9b b1       	in	r25, 0x0b	; 11
 6fa:	80 95       	com	r24
 6fc:	89 23       	and	r24, r25
 6fe:	8b b9       	out	0x0b, r24	; 11
 700:	08 95       	ret

00000702 <setShiftRegs>:
SCK-11(SHCP): SR Clock lädt neuen Wert mit steigender Flanke ins SR 
RCK-12(STCP): Storage Reg Clock steigende Flanke lädt SR in die Ausgänge
G-13(/OE)   : Output Enable muss immer 0 sein
*/
void setShiftRegs(unsigned long val)
{
 702:	8f 92       	push	r8
 704:	9f 92       	push	r9
 706:	af 92       	push	r10
 708:	bf 92       	push	r11
 70a:	cf 92       	push	r12
 70c:	df 92       	push	r13
 70e:	ef 92       	push	r14
 710:	ff 92       	push	r15
 712:	cf 93       	push	r28
 714:	df 93       	push	r29
 716:	6b 01       	movw	r12, r22
 718:	7c 01       	movw	r14, r24
	int i;

    if(val == 0)
 71a:	67 2b       	or	r22, r23
 71c:	68 2b       	or	r22, r24
 71e:	69 2b       	or	r22, r25
 720:	89 f4       	brne	.+34     	; 0x744 <setShiftRegs+0x42>
    {
        // setze alle Ausgänge auf 0
		portClr(PORTC, PORTC1);		// ziehe Reset
 722:	88 b1       	in	r24, 0x08	; 8
 724:	61 e0       	ldi	r22, 0x01	; 1
 726:	90 e0       	ldi	r25, 0x00	; 0
 728:	f3 d1       	rcall	.+998    	; 0xb10 <portClr>
		portSet(PORTC, PORTC2);		// auf die Ausgänge
 72a:	88 b1       	in	r24, 0x08	; 8
 72c:	62 e0       	ldi	r22, 0x02	; 2
 72e:	90 e0       	ldi	r25, 0x00	; 0
 730:	e3 d1       	rcall	.+966    	; 0xaf8 <portSet>
		portSet(PORTC, PORTC1);		// und zurück in die Grundstellung
 732:	88 b1       	in	r24, 0x08	; 8
 734:	61 e0       	ldi	r22, 0x01	; 1
 736:	90 e0       	ldi	r25, 0x00	; 0
 738:	df d1       	rcall	.+958    	; 0xaf8 <portSet>
		portClr(PORTC, PORTC2);
 73a:	88 b1       	in	r24, 0x08	; 8
 73c:	62 e0       	ldi	r22, 0x02	; 2
 73e:	90 e0       	ldi	r25, 0x00	; 0
 740:	e7 d1       	rcall	.+974    	; 0xb10 <portClr>
        return;
 742:	33 c0       	rjmp	.+102    	; 0x7aa <setShiftRegs+0xa8>
 744:	c7 e1       	ldi	r28, 0x17	; 23
 746:	d0 e0       	ldi	r29, 0x00	; 0
    }
    
    for(i=(24-1); i>=0; i--)
    {
        if(val & (1L << i))
 748:	81 2c       	mov	r8, r1
 74a:	91 2c       	mov	r9, r1
 74c:	54 01       	movw	r10, r8
 74e:	83 94       	inc	r8
 750:	d5 01       	movw	r26, r10
 752:	c4 01       	movw	r24, r8
 754:	0c 2e       	mov	r0, r28
 756:	04 c0       	rjmp	.+8      	; 0x760 <setShiftRegs+0x5e>
 758:	88 0f       	add	r24, r24
 75a:	99 1f       	adc	r25, r25
 75c:	aa 1f       	adc	r26, r26
 75e:	bb 1f       	adc	r27, r27
 760:	0a 94       	dec	r0
 762:	d2 f7       	brpl	.-12     	; 0x758 <setShiftRegs+0x56>
 764:	8c 21       	and	r24, r12
 766:	9d 21       	and	r25, r13
 768:	ae 21       	and	r26, r14
 76a:	bf 21       	and	r27, r15
 76c:	89 2b       	or	r24, r25
 76e:	8a 2b       	or	r24, r26
 770:	8b 2b       	or	r24, r27
 772:	29 f0       	breq	.+10     	; 0x77e <setShiftRegs+0x7c>
			portSet(PORTB, PORTB2);
 774:	85 b1       	in	r24, 0x05	; 5
 776:	62 e0       	ldi	r22, 0x02	; 2
 778:	90 e0       	ldi	r25, 0x00	; 0
 77a:	be d1       	rcall	.+892    	; 0xaf8 <portSet>
 77c:	04 c0       	rjmp	.+8      	; 0x786 <setShiftRegs+0x84>
        else  
			portClr(PORTB, PORTB2);
 77e:	85 b1       	in	r24, 0x05	; 5
 780:	62 e0       	ldi	r22, 0x02	; 2
 782:	90 e0       	ldi	r25, 0x00	; 0
 784:	c5 d1       	rcall	.+906    	; 0xb10 <portClr>
        
		portSet(PORTC, PORTC0);		// reinschieben
 786:	88 b1       	in	r24, 0x08	; 8
 788:	60 e0       	ldi	r22, 0x00	; 0
 78a:	90 e0       	ldi	r25, 0x00	; 0
 78c:	b5 d1       	rcall	.+874    	; 0xaf8 <portSet>
		portClr(PORTC, PORTC0);
 78e:	88 b1       	in	r24, 0x08	; 8
 790:	60 e0       	ldi	r22, 0x00	; 0
 792:	90 e0       	ldi	r25, 0x00	; 0
 794:	bd d1       	rcall	.+890    	; 0xb10 <portClr>
		portSet(PORTC, PORTC1);		// und zurück in die Grundstellung
		portClr(PORTC, PORTC2);
        return;
    }
    
    for(i=(24-1); i>=0; i--)
 796:	21 97       	sbiw	r28, 0x01	; 1
 798:	d8 f6       	brcc	.-74     	; 0x750 <setShiftRegs+0x4e>
        
		portSet(PORTC, PORTC0);		// reinschieben
		portClr(PORTC, PORTC0);
    }
    
	portSet(PORTC, PORTC2);			// auf die Ausgänge
 79a:	88 b1       	in	r24, 0x08	; 8
 79c:	62 e0       	ldi	r22, 0x02	; 2
 79e:	90 e0       	ldi	r25, 0x00	; 0
 7a0:	ab d1       	rcall	.+854    	; 0xaf8 <portSet>
	portClr(PORTC, PORTC2);
 7a2:	88 b1       	in	r24, 0x08	; 8
 7a4:	62 e0       	ldi	r22, 0x02	; 2
 7a6:	90 e0       	ldi	r25, 0x00	; 0
 7a8:	b3 d1       	rcall	.+870    	; 0xb10 <portClr>
}
 7aa:	df 91       	pop	r29
 7ac:	cf 91       	pop	r28
 7ae:	ff 90       	pop	r15
 7b0:	ef 90       	pop	r14
 7b2:	df 90       	pop	r13
 7b4:	cf 90       	pop	r12
 7b6:	bf 90       	pop	r11
 7b8:	af 90       	pop	r10
 7ba:	9f 90       	pop	r9
 7bc:	8f 90       	pop	r8
 7be:	08 95       	ret

000007c0 <pulserelais>:

// relnum: 0..35 entsprechend Relaisanschluss RELAIS0-35
void pulserelais(char relnum)
{
 7c0:	0f 93       	push	r16
 7c2:	1f 93       	push	r17
unsigned long sr, tmp;

    // direkt angeschlossene Relais
    switch (relnum)
 7c4:	48 2f       	mov	r20, r24
 7c6:	50 e0       	ldi	r21, 0x00	; 0
 7c8:	fa 01       	movw	r30, r20
 7ca:	78 97       	sbiw	r30, 0x18	; 24
 7cc:	ec 30       	cpi	r30, 0x0C	; 12
 7ce:	f1 05       	cpc	r31, r1
 7d0:	98 f5       	brcc	.+102    	; 0x838 <pulserelais+0x78>
 7d2:	e9 5d       	subi	r30, 0xD9	; 217
 7d4:	ff 4f       	sbci	r31, 0xFF	; 255
 7d6:	09 94       	ijmp
    {
        case 24: pulsedirectport('B',0); return;
 7d8:	60 e0       	ldi	r22, 0x00	; 0
 7da:	82 e4       	ldi	r24, 0x42	; 66
 7dc:	4a df       	rcall	.-364    	; 0x672 <pulsedirectport>
 7de:	46 c0       	rjmp	.+140    	; 0x86c <pulserelais+0xac>
        case 25: pulsedirectport('B',1); return;
 7e0:	61 e0       	ldi	r22, 0x01	; 1
 7e2:	82 e4       	ldi	r24, 0x42	; 66
 7e4:	46 df       	rcall	.-372    	; 0x672 <pulsedirectport>
 7e6:	42 c0       	rjmp	.+132    	; 0x86c <pulserelais+0xac>
        case 26: pulsedirectport('D',2); return;
 7e8:	62 e0       	ldi	r22, 0x02	; 2
 7ea:	84 e4       	ldi	r24, 0x44	; 68
 7ec:	42 df       	rcall	.-380    	; 0x672 <pulsedirectport>
 7ee:	3e c0       	rjmp	.+124    	; 0x86c <pulserelais+0xac>
        case 27: pulsedirectport('D',3); return;
 7f0:	63 e0       	ldi	r22, 0x03	; 3
 7f2:	84 e4       	ldi	r24, 0x44	; 68
 7f4:	3e df       	rcall	.-388    	; 0x672 <pulsedirectport>
 7f6:	3a c0       	rjmp	.+116    	; 0x86c <pulserelais+0xac>
        case 28: pulsedirectport('D',4); return;
 7f8:	64 e0       	ldi	r22, 0x04	; 4
 7fa:	84 e4       	ldi	r24, 0x44	; 68
 7fc:	3a df       	rcall	.-396    	; 0x672 <pulsedirectport>
 7fe:	36 c0       	rjmp	.+108    	; 0x86c <pulserelais+0xac>
        case 29: pulsedirectport('D',5); return;
 800:	65 e0       	ldi	r22, 0x05	; 5
 802:	84 e4       	ldi	r24, 0x44	; 68
 804:	36 df       	rcall	.-404    	; 0x672 <pulsedirectport>
 806:	32 c0       	rjmp	.+100    	; 0x86c <pulserelais+0xac>
        case 30: pulsedirectport('D',6); return;
 808:	66 e0       	ldi	r22, 0x06	; 6
 80a:	84 e4       	ldi	r24, 0x44	; 68
 80c:	32 df       	rcall	.-412    	; 0x672 <pulsedirectport>
 80e:	2e c0       	rjmp	.+92     	; 0x86c <pulserelais+0xac>
        case 31: pulsedirectport('D',7); return;        
 810:	67 e0       	ldi	r22, 0x07	; 7
 812:	84 e4       	ldi	r24, 0x44	; 68
 814:	2e df       	rcall	.-420    	; 0x672 <pulsedirectport>
 816:	2a c0       	rjmp	.+84     	; 0x86c <pulserelais+0xac>
        case 32: pulsedirectport('C',4); return;
 818:	64 e0       	ldi	r22, 0x04	; 4
 81a:	83 e4       	ldi	r24, 0x43	; 67
 81c:	2a df       	rcall	.-428    	; 0x672 <pulsedirectport>
 81e:	26 c0       	rjmp	.+76     	; 0x86c <pulserelais+0xac>
        case 33: pulsedirectport('C',5); return;
 820:	65 e0       	ldi	r22, 0x05	; 5
 822:	83 e4       	ldi	r24, 0x43	; 67
 824:	26 df       	rcall	.-436    	; 0x672 <pulsedirectport>
 826:	22 c0       	rjmp	.+68     	; 0x86c <pulserelais+0xac>
        case 34: pulsedirectport('B',4); return;
 828:	64 e0       	ldi	r22, 0x04	; 4
 82a:	82 e4       	ldi	r24, 0x42	; 66
 82c:	22 df       	rcall	.-444    	; 0x672 <pulsedirectport>
 82e:	1e c0       	rjmp	.+60     	; 0x86c <pulserelais+0xac>
        case 35: pulsedirectport('B',5); return;
 830:	65 e0       	ldi	r22, 0x05	; 5
 832:	82 e4       	ldi	r24, 0x42	; 66
 834:	1e df       	rcall	.-452    	; 0x672 <pulsedirectport>
 836:	1a c0       	rjmp	.+52     	; 0x86c <pulserelais+0xac>
    
    // Relais an Schieberegistern
    // Vorbelegen des Wertes
    tmp = relnum;
    sr = (1L<<tmp);
    setShiftRegs(sr);
 838:	41 e0       	ldi	r20, 0x01	; 1
 83a:	50 e0       	ldi	r21, 0x00	; 0
 83c:	60 e0       	ldi	r22, 0x00	; 0
 83e:	70 e0       	ldi	r23, 0x00	; 0
 840:	8a 01       	movw	r16, r20
 842:	9b 01       	movw	r18, r22
 844:	04 c0       	rjmp	.+8      	; 0x84e <pulserelais+0x8e>
 846:	00 0f       	add	r16, r16
 848:	11 1f       	adc	r17, r17
 84a:	22 1f       	adc	r18, r18
 84c:	33 1f       	adc	r19, r19
 84e:	8a 95       	dec	r24
 850:	d2 f7       	brpl	.-12     	; 0x846 <pulserelais+0x86>
 852:	c9 01       	movw	r24, r18
 854:	b8 01       	movw	r22, r16
 856:	55 df       	rcall	.-342    	; 0x702 <setShiftRegs>
 858:	8f e3       	ldi	r24, 0x3F	; 63
 85a:	9c e9       	ldi	r25, 0x9C	; 156
 85c:	01 97       	sbiw	r24, 0x01	; 1
 85e:	f1 f7       	brne	.-4      	; 0x85c <pulserelais+0x9c>
 860:	00 c0       	rjmp	.+0      	; 0x862 <pulserelais+0xa2>
 862:	00 00       	nop
    _delay_ms(20);
    setShiftRegs(0);    
 864:	60 e0       	ldi	r22, 0x00	; 0
 866:	70 e0       	ldi	r23, 0x00	; 0
 868:	cb 01       	movw	r24, r22
 86a:	4b df       	rcall	.-362    	; 0x702 <setShiftRegs>
}
 86c:	1f 91       	pop	r17
 86e:	0f 91       	pop	r16
 870:	08 95       	ret

00000872 <pulserelaisindex>:

void pulserelaisindex(unsigned char r)
{
unsigned char rn;

    switch (r)
 872:	48 2f       	mov	r20, r24
 874:	50 e0       	ldi	r21, 0x00	; 0
 876:	42 31       	cpi	r20, 0x12	; 18
 878:	51 05       	cpc	r21, r1
 87a:	38 f5       	brcc	.+78     	; 0x8ca <pulserelaisindex+0x58>
 87c:	fa 01       	movw	r30, r20
 87e:	ed 5c       	subi	r30, 0xCD	; 205
 880:	ff 4f       	sbci	r31, 0xFF	; 255
 882:	09 94       	ijmp
    { 
        // Cs
        case 0 :  rn = 0; break;
 884:	90 e0       	ldi	r25, 0x00	; 0
 886:	21 c0       	rjmp	.+66     	; 0x8ca <pulserelaisindex+0x58>
        case 1 :  rn = 2; break;
 888:	92 e0       	ldi	r25, 0x02	; 2
 88a:	1f c0       	rjmp	.+62     	; 0x8ca <pulserelaisindex+0x58>
        case 2 :  rn = 4; break;
 88c:	94 e0       	ldi	r25, 0x04	; 4
 88e:	1d c0       	rjmp	.+58     	; 0x8ca <pulserelaisindex+0x58>
        case 3 :  rn = 6; break;
 890:	96 e0       	ldi	r25, 0x06	; 6
 892:	1b c0       	rjmp	.+54     	; 0x8ca <pulserelaisindex+0x58>
        case 4 :  rn = 8; break;
 894:	98 e0       	ldi	r25, 0x08	; 8
 896:	19 c0       	rjmp	.+50     	; 0x8ca <pulserelaisindex+0x58>
        case 5 :  rn = 34; break;
 898:	92 e2       	ldi	r25, 0x22	; 34
 89a:	17 c0       	rjmp	.+46     	; 0x8ca <pulserelaisindex+0x58>
        case 6 :  rn = 10; break;
 89c:	9a e0       	ldi	r25, 0x0A	; 10
 89e:	15 c0       	rjmp	.+42     	; 0x8ca <pulserelaisindex+0x58>
        case 7 :  rn = 12; break;
 8a0:	9c e0       	ldi	r25, 0x0C	; 12
 8a2:	13 c0       	rjmp	.+38     	; 0x8ca <pulserelaisindex+0x58>
             
        // Ls
        case 8 :  rn = 14; break;
 8a4:	9e e0       	ldi	r25, 0x0E	; 14
 8a6:	11 c0       	rjmp	.+34     	; 0x8ca <pulserelaisindex+0x58>
        case 9 :  rn = 16; break;
 8a8:	90 e1       	ldi	r25, 0x10	; 16
 8aa:	0f c0       	rjmp	.+30     	; 0x8ca <pulserelaisindex+0x58>
        case 10:  rn = 18; break;
 8ac:	92 e1       	ldi	r25, 0x12	; 18
 8ae:	0d c0       	rjmp	.+26     	; 0x8ca <pulserelaisindex+0x58>
        case 11:  rn = 20; break;
 8b0:	94 e1       	ldi	r25, 0x14	; 20
 8b2:	0b c0       	rjmp	.+22     	; 0x8ca <pulserelaisindex+0x58>
        case 12:  rn = 22; break;
 8b4:	96 e1       	ldi	r25, 0x16	; 22
 8b6:	09 c0       	rjmp	.+18     	; 0x8ca <pulserelaisindex+0x58>
        case 13:  rn = 24; break;
 8b8:	98 e1       	ldi	r25, 0x18	; 24
 8ba:	07 c0       	rjmp	.+14     	; 0x8ca <pulserelaisindex+0x58>
        case 14:  rn = 26; break;
 8bc:	9a e1       	ldi	r25, 0x1A	; 26
 8be:	05 c0       	rjmp	.+10     	; 0x8ca <pulserelaisindex+0x58>
        case 15:  rn = 28; break;
 8c0:	9c e1       	ldi	r25, 0x1C	; 28
 8c2:	03 c0       	rjmp	.+6      	; 0x8ca <pulserelaisindex+0x58>
             
        // V oder H
        case 16:  rn = 30; break;
 8c4:	9e e1       	ldi	r25, 0x1E	; 30
 8c6:	01 c0       	rjmp	.+2      	; 0x8ca <pulserelaisindex+0x58>
        case 17:  rn = 32; break;
 8c8:	90 e2       	ldi	r25, 0x20	; 32
    }
    
    if(relais[r] == 0)
 8ca:	e8 2f       	mov	r30, r24
 8cc:	f0 e0       	ldi	r31, 0x00	; 0
 8ce:	ed 59       	subi	r30, 0x9D	; 157
 8d0:	fe 4f       	sbci	r31, 0xFE	; 254
 8d2:	80 81       	ld	r24, Z
 8d4:	81 11       	cpse	r24, r1
 8d6:	04 c0       	rjmp	.+8      	; 0x8e0 <pulserelaisindex+0x6e>
        pulserelais(rn+1);
 8d8:	81 e0       	ldi	r24, 0x01	; 1
 8da:	89 0f       	add	r24, r25
 8dc:	71 df       	rcall	.-286    	; 0x7c0 <pulserelais>
 8de:	08 95       	ret
    else
        pulserelais(rn); 
 8e0:	89 2f       	mov	r24, r25
 8e2:	6e df       	rcall	.-292    	; 0x7c0 <pulserelais>
 8e4:	08 95       	ret

000008e6 <moveRelais>:
}

void moveRelais()
{
 8e6:	af 92       	push	r10
 8e8:	bf 92       	push	r11
 8ea:	cf 92       	push	r12
 8ec:	df 92       	push	r13
 8ee:	ef 92       	push	r14
 8f0:	ff 92       	push	r15
 8f2:	0f 93       	push	r16
 8f4:	1f 93       	push	r17
 8f6:	cf 93       	push	r28
 8f8:	03 e6       	ldi	r16, 0x63	; 99
 8fa:	11 e0       	ldi	r17, 0x01	; 1
 8fc:	0f 2e       	mov	r0, r31
 8fe:	f1 e5       	ldi	r31, 0x51	; 81
 900:	ef 2e       	mov	r14, r31
 902:	f1 e0       	ldi	r31, 0x01	; 1
 904:	ff 2e       	mov	r15, r31
 906:	f0 2d       	mov	r31, r0
 908:	57 01       	movw	r10, r14
 90a:	68 01       	movw	r12, r16
unsigned char i;

    for(i=0; i<18; i++)
 90c:	c0 e0       	ldi	r28, 0x00	; 0
    {
        if(relais[i] != oldrelais[i])
 90e:	f6 01       	movw	r30, r12
 910:	91 91       	ld	r25, Z+
 912:	6f 01       	movw	r12, r30
 914:	f5 01       	movw	r30, r10
 916:	81 91       	ld	r24, Z+
 918:	5f 01       	movw	r10, r30
 91a:	98 17       	cp	r25, r24
 91c:	11 f0       	breq	.+4      	; 0x922 <moveRelais+0x3c>
        {
            pulserelaisindex(i);
 91e:	8c 2f       	mov	r24, r28
 920:	a8 df       	rcall	.-176    	; 0x872 <pulserelaisindex>

void moveRelais()
{
unsigned char i;

    for(i=0; i<18; i++)
 922:	cf 5f       	subi	r28, 0xFF	; 255
 924:	c2 31       	cpi	r28, 0x12	; 18
 926:	99 f7       	brne	.-26     	; 0x90e <moveRelais+0x28>
 928:	25 e7       	ldi	r18, 0x75	; 117
 92a:	31 e0       	ldi	r19, 0x01	; 1
            pulserelaisindex(i);
        }
    }

    for(i=0; i<18; i++) 
        oldrelais[i] = relais[i];
 92c:	f8 01       	movw	r30, r16
 92e:	81 91       	ld	r24, Z+
 930:	8f 01       	movw	r16, r30
 932:	f7 01       	movw	r30, r14
 934:	81 93       	st	Z+, r24
 936:	7f 01       	movw	r14, r30
        {
            pulserelaisindex(i);
        }
    }

    for(i=0; i<18; i++) 
 938:	02 17       	cp	r16, r18
 93a:	13 07       	cpc	r17, r19
 93c:	b9 f7       	brne	.-18     	; 0x92c <moveRelais+0x46>
        oldrelais[i] = relais[i];
}
 93e:	cf 91       	pop	r28
 940:	1f 91       	pop	r17
 942:	0f 91       	pop	r16
 944:	ff 90       	pop	r15
 946:	ef 90       	pop	r14
 948:	df 90       	pop	r13
 94a:	cf 90       	pop	r12
 94c:	bf 90       	pop	r11
 94e:	af 90       	pop	r10
 950:	08 95       	ret

00000952 <switchRelais>:

void switchRelais()
{
 952:	8f 92       	push	r8
 954:	9f 92       	push	r9
 956:	af 92       	push	r10
 958:	bf 92       	push	r11
 95a:	cf 92       	push	r12
 95c:	df 92       	push	r13
 95e:	ef 92       	push	r14
 960:	ff 92       	push	r15
unsigned long i;

	if(valid == 0 && shortvalid == 0) return;	// kein Kommando
 962:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <valid>
 966:	81 11       	cpse	r24, r1
 968:	05 c0       	rjmp	.+10     	; 0x974 <switchRelais+0x22>
 96a:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <shortvalid>
 96e:	81 11       	cpse	r24, r1
 970:	32 c0       	rjmp	.+100    	; 0x9d6 <switchRelais+0x84>
 972:	56 c0       	rjmp	.+172    	; 0xa20 <switchRelais+0xce>

	// Textkommandos
    if(valid != 0)
	{ 
		// Belege die Relaisvariable vor
		if(command == 'C')
 974:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <command>
 978:	83 34       	cpi	r24, 0x43	; 67
 97a:	49 f4       	brne	.+18     	; 0x98e <switchRelais+0x3c>
		{          
			relais[(int)parameter] = action;                        
 97c:	e0 91 78 01 	lds	r30, 0x0178	; 0x800178 <parameter>
 980:	f0 e0       	ldi	r31, 0x00	; 0
 982:	ed 59       	subi	r30, 0x9D	; 157
 984:	fe 4f       	sbci	r31, 0xFE	; 254
 986:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <action>
 98a:	90 83       	st	Z, r25
 98c:	16 c0       	rjmp	.+44     	; 0x9ba <switchRelais+0x68>
		}
     
		if(command == 'L')
 98e:	8c 34       	cpi	r24, 0x4C	; 76
 990:	49 f4       	brne	.+18     	; 0x9a4 <switchRelais+0x52>
		{          
			relais[(int)parameter + 8] = action;                       
 992:	e0 91 78 01 	lds	r30, 0x0178	; 0x800178 <parameter>
 996:	f0 e0       	ldi	r31, 0x00	; 0
 998:	ed 59       	subi	r30, 0x9D	; 157
 99a:	fe 4f       	sbci	r31, 0xFE	; 254
 99c:	80 91 7a 01 	lds	r24, 0x017A	; 0x80017a <action>
 9a0:	80 87       	std	Z+8, r24	; 0x08
 9a2:	15 c0       	rjmp	.+42     	; 0x9ce <switchRelais+0x7c>
		}
    
		if(command == 'V')
 9a4:	86 35       	cpi	r24, 0x56	; 86
 9a6:	49 f4       	brne	.+18     	; 0x9ba <switchRelais+0x68>
		{          
			relais[16] = action;
 9a8:	80 91 7a 01 	lds	r24, 0x017A	; 0x80017a <action>
 9ac:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <relais+0x10>
			if(action == 1) relais[17] = 0;
 9b0:	81 30       	cpi	r24, 0x01	; 1
 9b2:	69 f4       	brne	.+26     	; 0x9ce <switchRelais+0x7c>
 9b4:	10 92 74 01 	sts	0x0174, r1	; 0x800174 <relais+0x11>
 9b8:	0a c0       	rjmp	.+20     	; 0x9ce <switchRelais+0x7c>
		} 

		if(command == 'H')
 9ba:	88 34       	cpi	r24, 0x48	; 72
 9bc:	41 f4       	brne	.+16     	; 0x9ce <switchRelais+0x7c>
		{          
			relais[17] = action;                       
 9be:	80 91 7a 01 	lds	r24, 0x017A	; 0x80017a <action>
 9c2:	80 93 74 01 	sts	0x0174, r24	; 0x800174 <relais+0x11>
			if(action == 1) relais[16] = 0;
 9c6:	81 30       	cpi	r24, 0x01	; 1
 9c8:	11 f4       	brne	.+4      	; 0x9ce <switchRelais+0x7c>
 9ca:	10 92 73 01 	sts	0x0173, r1	; 0x800173 <relais+0x10>
		} 
	}  

	// Kommando in Kurzform
	if(shortvalid != 0)
 9ce:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <shortvalid>
 9d2:	88 23       	and	r24, r24
 9d4:	01 f1       	breq	.+64     	; 0xa16 <switchRelais+0xc4>
		 Bit 16 = V
		 Bit 17 = H
		*/
		for(i=0; i<18; i++)
		{
			relais[i] = (shortval & (1UL<<i)) ? 1 : 0;
 9d6:	c0 90 4c 01 	lds	r12, 0x014C	; 0x80014c <shortval>
 9da:	d0 90 4d 01 	lds	r13, 0x014D	; 0x80014d <shortval+0x1>
 9de:	e0 90 4e 01 	lds	r14, 0x014E	; 0x80014e <shortval+0x2>
 9e2:	f0 90 4f 01 	lds	r15, 0x014F	; 0x80014f <shortval+0x3>
 9e6:	43 e6       	ldi	r20, 0x63	; 99
 9e8:	51 e0       	ldi	r21, 0x01	; 1
 9ea:	25 e7       	ldi	r18, 0x75	; 117
 9ec:	31 e0       	ldi	r19, 0x01	; 1
 9ee:	fa 01       	movw	r30, r20
 9f0:	cf 01       	movw	r24, r30
 9f2:	84 1b       	sub	r24, r20
 9f4:	95 0b       	sbc	r25, r21
 9f6:	46 01       	movw	r8, r12
 9f8:	57 01       	movw	r10, r14
 9fa:	04 c0       	rjmp	.+8      	; 0xa04 <switchRelais+0xb2>
 9fc:	b6 94       	lsr	r11
 9fe:	a7 94       	ror	r10
 a00:	97 94       	ror	r9
 a02:	87 94       	ror	r8
 a04:	8a 95       	dec	r24
 a06:	d2 f7       	brpl	.-12     	; 0x9fc <switchRelais+0xaa>
 a08:	d5 01       	movw	r26, r10
 a0a:	c4 01       	movw	r24, r8
 a0c:	81 70       	andi	r24, 0x01	; 1
 a0e:	81 93       	st	Z+, r24
		 Bit 0..7 = C0..7
		 Bit 8..15 = L0..7
		 Bit 16 = V
		 Bit 17 = H
		*/
		for(i=0; i<18; i++)
 a10:	e2 17       	cp	r30, r18
 a12:	f3 07       	cpc	r31, r19
 a14:	69 f7       	brne	.-38     	; 0x9f0 <switchRelais+0x9e>
			relais[i] = (shortval & (1UL<<i)) ? 1 : 0;
		}
	}
    
    // steuere geänderte Relais an
    moveRelais();
 a16:	67 df       	rcall	.-306    	; 0x8e6 <moveRelais>
    
    valid = 0;
 a18:	10 92 50 01 	sts	0x0150, r1	; 0x800150 <valid>
	shortvalid = 0;
 a1c:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <shortvalid>
}
 a20:	ff 90       	pop	r15
 a22:	ef 90       	pop	r14
 a24:	df 90       	pop	r13
 a26:	cf 90       	pop	r12
 a28:	bf 90       	pop	r11
 a2a:	af 90       	pop	r10
 a2c:	9f 90       	pop	r9
 a2e:	8f 90       	pop	r8
 a30:	08 95       	ret

00000a32 <forceRelais>:

void forceRelais(char cmd, char num, char act)
{
	command = cmd;
 a32:	80 93 79 01 	sts	0x0179, r24	; 0x800179 <command>
	parameter = num;
 a36:	60 93 78 01 	sts	0x0178, r22	; 0x800178 <parameter>
	action = act;
 a3a:	40 93 7a 01 	sts	0x017A, r20	; 0x80017a <action>
	valid = 1; 
 a3e:	81 e0       	ldi	r24, 0x01	; 1
 a40:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <valid>
	switchRelais();
 a44:	86 df       	rcall	.-244    	; 0x952 <switchRelais>
 a46:	08 95       	ret

00000a48 <Grundstellung>:

}

void Grundstellung()
{
 a48:	cf 93       	push	r28
 a4a:	e1 e5       	ldi	r30, 0x51	; 81
 a4c:	f1 e0       	ldi	r31, 0x01	; 1
 a4e:	23 e6       	ldi	r18, 0x63	; 99
 a50:	31 e0       	ldi	r19, 0x01	; 1
char i;

	for(i=0; i<18; i++)
		oldrelais[(int)i] = 255;
 a52:	8f ef       	ldi	r24, 0xFF	; 255
 a54:	81 93       	st	Z+, r24

void Grundstellung()
{
char i;

	for(i=0; i<18; i++)
 a56:	2e 17       	cp	r18, r30
 a58:	3f 07       	cpc	r19, r31
 a5a:	e1 f7       	brne	.-8      	; 0xa54 <Grundstellung+0xc>
 a5c:	c0 e0       	ldi	r28, 0x00	; 0
		oldrelais[(int)i] = 255;

	for(i=1; i<=8; i++)
	{
		forceRelais('C',i-1,0);
 a5e:	40 e0       	ldi	r20, 0x00	; 0
 a60:	6c 2f       	mov	r22, r28
 a62:	83 e4       	ldi	r24, 0x43	; 67
 a64:	e6 df       	rcall	.-52     	; 0xa32 <forceRelais>
 a66:	cf 5f       	subi	r28, 0xFF	; 255
char i;

	for(i=0; i<18; i++)
		oldrelais[(int)i] = 255;

	for(i=1; i<=8; i++)
 a68:	c8 30       	cpi	r28, 0x08	; 8
 a6a:	c9 f7       	brne	.-14     	; 0xa5e <Grundstellung+0x16>
	{
		forceRelais('C',i-1,0);
	}
	
	forceRelais('V',0,0);
 a6c:	40 e0       	ldi	r20, 0x00	; 0
 a6e:	60 e0       	ldi	r22, 0x00	; 0
 a70:	86 e5       	ldi	r24, 0x56	; 86
 a72:	df df       	rcall	.-66     	; 0xa32 <forceRelais>
	forceRelais('H',0,0);
 a74:	40 e0       	ldi	r20, 0x00	; 0
 a76:	60 e0       	ldi	r22, 0x00	; 0
 a78:	88 e4       	ldi	r24, 0x48	; 72
 a7a:	db df       	rcall	.-74     	; 0xa32 <forceRelais>
 a7c:	c0 e0       	ldi	r28, 0x00	; 0

	for(i=1; i<=8; i++)
	{
		forceRelais('L',i-1,1);
 a7e:	41 e0       	ldi	r20, 0x01	; 1
 a80:	6c 2f       	mov	r22, r28
 a82:	8c e4       	ldi	r24, 0x4C	; 76
 a84:	d6 df       	rcall	.-84     	; 0xa32 <forceRelais>
 a86:	cf 5f       	subi	r28, 0xFF	; 255
	}
	
	forceRelais('V',0,0);
	forceRelais('H',0,0);

	for(i=1; i<=8; i++)
 a88:	c8 30       	cpi	r28, 0x08	; 8
 a8a:	c9 f7       	brne	.-14     	; 0xa7e <Grundstellung+0x36>
	{
		forceRelais('L',i-1,1);
	}
}
 a8c:	cf 91       	pop	r28
 a8e:	08 95       	ret

00000a90 <__vector_18>:
// This flag is set on USART Receiver buffer overflow
bool rx_buffer_overflow0;

// USART Receiver interrupt service routine
ISR(USART_RX_vect)
{
 a90:	1f 92       	push	r1
 a92:	0f 92       	push	r0
 a94:	0f b6       	in	r0, 0x3f	; 63
 a96:	0f 92       	push	r0
 a98:	11 24       	eor	r1, r1
 a9a:	8f 93       	push	r24
 a9c:	9f 93       	push	r25
 a9e:	ef 93       	push	r30
 aa0:	ff 93       	push	r31
unsigned char status;
char data;
status=UCSR0A;
 aa2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
data=UDR0;
 aa6:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
 aaa:	8c 71       	andi	r24, 0x1C	; 28
 aac:	e1 f4       	brne	.+56     	; 0xae6 <__vector_18+0x56>
   {
   rx_buffer0[rx_wr_index0++]=data;
 aae:	e0 91 77 01 	lds	r30, 0x0177	; 0x800177 <rx_wr_index0>
 ab2:	81 e0       	ldi	r24, 0x01	; 1
 ab4:	8e 0f       	add	r24, r30
 ab6:	80 93 77 01 	sts	0x0177, r24	; 0x800177 <rx_wr_index0>
 aba:	f0 e0       	ldi	r31, 0x00	; 0
 abc:	e5 58       	subi	r30, 0x85	; 133
 abe:	fe 4f       	sbci	r31, 0xFE	; 254
 ac0:	90 83       	st	Z, r25
#if RX_BUFFER_SIZE0 == 256
   // special case for receiver buffer size=256
   if (++rx_counter0 == 0) rx_buffer_overflow0=1;
#else
   if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
 ac2:	80 91 77 01 	lds	r24, 0x0177	; 0x800177 <rx_wr_index0>
 ac6:	80 38       	cpi	r24, 0x80	; 128
 ac8:	11 f4       	brne	.+4      	; 0xace <__vector_18+0x3e>
 aca:	10 92 77 01 	sts	0x0177, r1	; 0x800177 <rx_wr_index0>
   if (++rx_counter0 == RX_BUFFER_SIZE0)
 ace:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <rx_counter0>
 ad2:	8f 5f       	subi	r24, 0xFF	; 255
 ad4:	80 93 75 01 	sts	0x0175, r24	; 0x800175 <rx_counter0>
 ad8:	80 38       	cpi	r24, 0x80	; 128
 ada:	29 f4       	brne	.+10     	; 0xae6 <__vector_18+0x56>
      {
      rx_counter0=0;
 adc:	10 92 75 01 	sts	0x0175, r1	; 0x800175 <rx_counter0>
      rx_buffer_overflow0=1;
 ae0:	81 e0       	ldi	r24, 0x01	; 1
 ae2:	80 93 fb 01 	sts	0x01FB, r24	; 0x8001fb <rx_buffer_overflow0>
      }
#endif
   }
}
 ae6:	ff 91       	pop	r31
 ae8:	ef 91       	pop	r30
 aea:	9f 91       	pop	r25
 aec:	8f 91       	pop	r24
 aee:	0f 90       	pop	r0
 af0:	0f be       	out	0x3f, r0	; 63
 af2:	0f 90       	pop	r0
 af4:	1f 90       	pop	r1
 af6:	18 95       	reti

00000af8 <portSet>:
// Set a port bit
void portSet(uint16_t port, char bitPos)
{
	uint8_t *const adr = (uint8_t*) port;

	*adr |= (1 << bitPos);
 af8:	21 e0       	ldi	r18, 0x01	; 1
 afa:	30 e0       	ldi	r19, 0x00	; 0
 afc:	02 c0       	rjmp	.+4      	; 0xb02 <portSet+0xa>
 afe:	22 0f       	add	r18, r18
 b00:	33 1f       	adc	r19, r19
 b02:	6a 95       	dec	r22
 b04:	e2 f7       	brpl	.-8      	; 0xafe <portSet+0x6>
 b06:	fc 01       	movw	r30, r24
 b08:	30 81       	ld	r19, Z
 b0a:	23 2b       	or	r18, r19
 b0c:	20 83       	st	Z, r18
 b0e:	08 95       	ret

00000b10 <portClr>:
// Clear a port bit
void portClr(uint16_t port, char bitPos)
{
	uint8_t *const adr = (uint8_t*) port;

	*adr &= ~(1 << bitPos);
 b10:	21 e0       	ldi	r18, 0x01	; 1
 b12:	30 e0       	ldi	r19, 0x00	; 0
 b14:	02 c0       	rjmp	.+4      	; 0xb1a <portClr+0xa>
 b16:	22 0f       	add	r18, r18
 b18:	33 1f       	adc	r19, r19
 b1a:	6a 95       	dec	r22
 b1c:	e2 f7       	brpl	.-8      	; 0xb16 <portClr+0x6>
 b1e:	20 95       	com	r18
 b20:	fc 01       	movw	r30, r24
 b22:	30 81       	ld	r19, Z
 b24:	23 23       	and	r18, r19
 b26:	20 83       	st	Z, r18
 b28:	08 95       	ret

00000b2a <dataAvailable>:
#define _ALTERNATE_GETCHAR_
//#pragma used+

char dataAvailable()
{
    return rx_counter0;
 b2a:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <rx_counter0>
}
 b2e:	08 95       	ret

00000b30 <tuner_getchar>:

char tuner_getchar(void)
{
 b30:	cf 93       	push	r28
    char data;

    while (rx_counter0==0);
 b32:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <rx_counter0>
 b36:	88 23       	and	r24, r24
 b38:	e1 f3       	breq	.-8      	; 0xb32 <tuner_getchar+0x2>

    data=rx_buffer0[rx_rd_index0++];
 b3a:	e0 91 76 01 	lds	r30, 0x0176	; 0x800176 <rx_rd_index0>
 b3e:	81 e0       	ldi	r24, 0x01	; 1
 b40:	8e 0f       	add	r24, r30
 b42:	80 93 76 01 	sts	0x0176, r24	; 0x800176 <rx_rd_index0>
 b46:	f0 e0       	ldi	r31, 0x00	; 0
 b48:	e5 58       	subi	r30, 0x85	; 133
 b4a:	fe 4f       	sbci	r31, 0xFE	; 254
 b4c:	c0 81       	ld	r28, Z
	// echo
	putchar(data);
 b4e:	60 91 fe 01 	lds	r22, 0x01FE	; 0x8001fe <__iob+0x2>
 b52:	70 91 ff 01 	lds	r23, 0x01FF	; 0x8001ff <__iob+0x3>
 b56:	8c 2f       	mov	r24, r28
 b58:	90 e0       	ldi	r25, 0x00	; 0
 b5a:	6b d0       	rcall	.+214    	; 0xc32 <fputc>

    #if RX_BUFFER_SIZE0 != 256
		if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
 b5c:	80 91 76 01 	lds	r24, 0x0176	; 0x800176 <rx_rd_index0>
 b60:	80 38       	cpi	r24, 0x80	; 128
 b62:	11 f4       	brne	.+4      	; 0xb68 <tuner_getchar+0x38>
 b64:	10 92 76 01 	sts	0x0176, r1	; 0x800176 <rx_rd_index0>
    #endif

	cpu_irq_disable();
 b68:	f8 94       	cli
    --rx_counter0;
 b6a:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <rx_counter0>
 b6e:	81 50       	subi	r24, 0x01	; 1
 b70:	80 93 75 01 	sts	0x0175, r24	; 0x800175 <rx_counter0>
	cpu_irq_enable();
 b74:	78 94       	sei

    return data;
}
 b76:	8c 2f       	mov	r24, r28
 b78:	cf 91       	pop	r28
 b7a:	08 95       	ret

00000b7c <tuner_main>:

void tuner_main(void)
{
    // Crystal Oscillator division factor: 1
//  #pragma optsize-
    CLKPR=(1<<CLKPCE);
 b7c:	e1 e6       	ldi	r30, 0x61	; 97
 b7e:	f0 e0       	ldi	r31, 0x00	; 0
 b80:	80 e8       	ldi	r24, 0x80	; 128
 b82:	80 83       	st	Z, r24
    CLKPR=(0<<CLKPCE) | (0<<CLKPS3) | (0<<CLKPS2) | (0<<CLKPS1) | (0<<CLKPS0);
 b84:	10 82       	st	Z, r1
//  #endif

    // Input/Output Ports initialization
    // Port B initialization
    // Function: Bit5=Out Bit4=Out Bit3=Out Bit2=Out Bit1=Out Bit0=Out 
    DDRB= (1<<DDB5) | (1<<DDB4) | (1<<DDB3) | (1<<DDB2) | (1<<DDB1) | (1<<DDB0);
 b86:	9f e3       	ldi	r25, 0x3F	; 63
 b88:	94 b9       	out	0x04, r25	; 4
    // State: Bit7=0 Bit6=0 Bit5=0 Bit4=0 Bit3=0 Bit2=0 Bit1=0 Bit0=0 
    PORTB= (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORTB1) | (0<<PORTB0);
 b8a:	15 b8       	out	0x05, r1	; 5

    // Port C initialization
    // Function: Bit5=Out Bit4=Out Bit3=Out Bit2=Out Bit1=Out Bit0=Out 
    DDRC= (1<<DDC5) | (1<<DDC4) | (1<<DDC3) | (1<<DDC2) | (1<<DDC1) | (1<<DDC0);
 b8c:	97 b9       	out	0x07, r25	; 7
    // State: Bit6=0 Bit5=0 Bit4=0 Bit3=0 Bit2=0 Bit1=1 Bit0=0 
    PORTC= (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (1<<PORTC1) | (0<<PORTC0);
 b8e:	92 e0       	ldi	r25, 0x02	; 2
 b90:	98 b9       	out	0x08, r25	; 8

    // Port D initialization
    // Function: Bit7=Out Bit6=Out Bit5=Out Bit4=Out Bit3=Out Bit2=Out Bit1=Out Bit0=In 
    DDRD=(1<<DDD7) | (1<<DDD6) | (1<<DDD5) | (1<<DDD4) | (1<<DDD3) | (1<<DDD2) | (1<<DDD1) | (0<<DDD0);
 b92:	9e ef       	ldi	r25, 0xFE	; 254
 b94:	9a b9       	out	0x0a, r25	; 10
    // State: Bit7=0 Bit6=0 Bit5=0 Bit4=0 Bit3=0 Bit2=0 Bit1=0 Bit0=T 
    PORTD=(0<<PORTD7) | (0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (0<<PORTD3) | (0<<PORTD2) | (0<<PORTD1) | (0<<PORTD0);
 b96:	1b b8       	out	0x0b, r1	; 11
    // Clock source: System Clock
    // Clock value: Timer 0 Stopped
    // Mode: Normal top=0xFF
    // OC0A output: Disconnected
    // OC0B output: Disconnected
    TCCR0A=(0<<COM0A1) | (0<<COM0A0) | (0<<COM0B1) | (0<<COM0B0) | (0<<WGM01) | (0<<WGM00);
 b98:	14 bc       	out	0x24, r1	; 36
    TCCR0B=(0<<WGM02) | (0<<CS02) | (0<<CS01) | (0<<CS00);
 b9a:	15 bc       	out	0x25, r1	; 37
    TCNT0=0x00;
 b9c:	16 bc       	out	0x26, r1	; 38
    OCR0A=0x00;
 b9e:	17 bc       	out	0x27, r1	; 39
    OCR0B=0x00;
 ba0:	18 bc       	out	0x28, r1	; 40
    // Input Capture on Falling Edge
    // Timer1 Overflow Interrupt: Off
    // Input Capture Interrupt: Off
    // Compare A Match Interrupt: Off
    // Compare B Match Interrupt: Off
    TCCR1A=(0<<COM1A1) | (0<<COM1A0) | (0<<COM1B1) | (0<<COM1B0) | (0<<WGM11) | (0<<WGM10);
 ba2:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__EEPROM_REGION_LENGTH__+0x7f0080>
    TCCR1B=(0<<ICNC1) | (0<<ICES1) | (0<<WGM13) | (0<<WGM12) | (0<<CS12) | (0<<CS11) | (0<<CS10);
 ba6:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__EEPROM_REGION_LENGTH__+0x7f0081>
    TCNT1H=0x00;
 baa:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__EEPROM_REGION_LENGTH__+0x7f0085>
    TCNT1L=0x00;
 bae:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__EEPROM_REGION_LENGTH__+0x7f0084>
    ICR1H=0x00;
 bb2:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <__EEPROM_REGION_LENGTH__+0x7f0087>
    ICR1L=0x00;
 bb6:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <__EEPROM_REGION_LENGTH__+0x7f0086>
    OCR1AH=0x00;
 bba:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__EEPROM_REGION_LENGTH__+0x7f0089>
    OCR1AL=0x00;
 bbe:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__EEPROM_REGION_LENGTH__+0x7f0088>
    OCR1BH=0x00;
 bc2:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__EEPROM_REGION_LENGTH__+0x7f008b>
    OCR1BL=0x00;
 bc6:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__EEPROM_REGION_LENGTH__+0x7f008a>
    // Clock source: System Clock
    // Clock value: Timer2 Stopped
    // Mode: Normal top=0xFF
    // OC2A output: Disconnected
    // OC2B output: Disconnected
    ASSR=(0<<EXCLK) | (0<<AS2);
 bca:	10 92 b6 00 	sts	0x00B6, r1	; 0x8000b6 <__EEPROM_REGION_LENGTH__+0x7f00b6>
    TCCR2A=(0<<COM2A1) | (0<<COM2A0) | (0<<COM2B1) | (0<<COM2B0) | (0<<WGM21) | (0<<WGM20);
 bce:	10 92 b0 00 	sts	0x00B0, r1	; 0x8000b0 <__EEPROM_REGION_LENGTH__+0x7f00b0>
    TCCR2B=(0<<WGM22) | (0<<CS22) | (0<<CS21) | (0<<CS20);
 bd2:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__EEPROM_REGION_LENGTH__+0x7f00b1>
    TCNT2=0x00;
 bd6:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__EEPROM_REGION_LENGTH__+0x7f00b2>
    OCR2A=0x00;
 bda:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__EEPROM_REGION_LENGTH__+0x7f00b3>
    OCR2B=0x00;
 bde:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__EEPROM_REGION_LENGTH__+0x7f00b4>

    // Timer/Counter 0 Interrupt(s) initialization
    TIMSK0=(0<<OCIE0B) | (0<<OCIE0A) | (0<<TOIE0);
 be2:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>

    // Timer/Counter 1 Interrupt(s) initialization
    TIMSK1=(0<<ICIE1) | (0<<OCIE1B) | (0<<OCIE1A) | (0<<TOIE1);
 be6:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__EEPROM_REGION_LENGTH__+0x7f006f>

    // Timer/Counter 2 Interrupt(s) initialization
    TIMSK2=(0<<OCIE2B) | (0<<OCIE2A) | (0<<TOIE2);
 bea:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__EEPROM_REGION_LENGTH__+0x7f0070>
    // INT0: Off
    // INT1: Off
    // Interrupt on any change on pins PCINT0-7: Off
    // Interrupt on any change on pins PCINT8-14: Off
    // Interrupt on any change on pins PCINT16-23: Off
    EICRA=(0<<ISC11) | (0<<ISC10) | (0<<ISC01) | (0<<ISC00);
 bee:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__EEPROM_REGION_LENGTH__+0x7f0069>
    EIMSK=(0<<INT1) | (0<<INT0);
 bf2:	1d ba       	out	0x1d, r1	; 29
    PCICR=(0<<PCIE2) | (0<<PCIE1) | (0<<PCIE0);
 bf4:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <__EEPROM_REGION_LENGTH__+0x7f0068>
    // Communication Parameters: 8 Data, 1 Stop, No Parity
    // USART Receiver: On
    // USART Transmitter: On
    // USART0 Mode: Asynchronous
    // USART Baud Rate: 9600
    UCSR0A=(0<<RXC0) | (0<<TXC0) | (0<<UDRE0) | (0<<FE0) | (0<<DOR0) | (0<<UPE0) | (0<<U2X0) | (0<<MPCM0);
 bf8:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
    UCSR0B=(1<<RXCIE0) | (0<<TXCIE0) | (0<<UDRIE0) | (1<<RXEN0) | (1<<TXEN0) | (0<<UCSZ02) | (0<<RXB80) | (0<<TXB80);
 bfc:	98 e9       	ldi	r25, 0x98	; 152
 bfe:	90 93 c1 00 	sts	0x00C1, r25	; 0x8000c1 <__EEPROM_REGION_LENGTH__+0x7f00c1>
    UCSR0C=(0<<UMSEL01) | (0<<UMSEL00) | (0<<UPM01) | (0<<UPM00) | (0<<USBS0) | (1<<UCSZ01) | (1<<UCSZ00) | (0<<UCPOL0);
 c02:	96 e0       	ldi	r25, 0x06	; 6
 c04:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__EEPROM_REGION_LENGTH__+0x7f00c2>
    /* 9600:
	UBRR0H=0x00;
    UBRR0L=0x33;*/

	// 1200:
	UBRR0H=0x01;
 c08:	91 e0       	ldi	r25, 0x01	; 1
 c0a:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__EEPROM_REGION_LENGTH__+0x7f00c5>
	UBRR0L=0xA0;
 c0e:	90 ea       	ldi	r25, 0xA0	; 160
 c10:	90 93 c4 00 	sts	0x00C4, r25	; 0x8000c4 <__EEPROM_REGION_LENGTH__+0x7f00c4>
    // Analog Comparator: Off
    // The Analog Comparator's positive input is
    // connected to the AIN0 pin
    // The Analog Comparator's negative input is
    // connected to the AIN1 pin
    ACSR=(1<<ACD) | (0<<ACBG) | (0<<ACO) | (0<<ACI) | (0<<ACIE) | (0<<ACIC) | (0<<ACIS1) | (0<<ACIS0);
 c14:	80 bf       	out	0x30, r24	; 48
    ADCSRB=(0<<ACME);
 c16:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__EEPROM_REGION_LENGTH__+0x7f007b>
    // Digital input buffer on AIN0: On
    // Digital input buffer on AIN1: On
    DIDR1=(0<<AIN0D) | (0<<AIN1D);
 c1a:	10 92 7f 00 	sts	0x007F, r1	; 0x80007f <__EEPROM_REGION_LENGTH__+0x7f007f>

    // ADC initialization
    // ADC disabled
    ADCSRA=(0<<ADEN) | (0<<ADSC) | (0<<ADATE) | (0<<ADIF) | (0<<ADIE) | (0<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
 c1e:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__EEPROM_REGION_LENGTH__+0x7f007a>

    // SPI initialization
    // SPI disabled
    SPCR=(0<<SPIE) | (0<<SPE) | (0<<DORD) | (0<<MSTR) | (0<<CPOL) | (0<<CPHA) | (0<<SPR1) | (0<<SPR0);
 c22:	1c bc       	out	0x2c, r1	; 44

    // TWI initialization
    // TWI disabled
    TWCR=(0<<TWEA) | (0<<TWSTA) | (0<<TWSTO) | (0<<TWEN) | (0<<TWIE);
 c24:	10 92 bc 00 	sts	0x00BC, r1	; 0x8000bc <__EEPROM_REGION_LENGTH__+0x7f00bc>

    // Globally enable interrupts
	cpu_irq_enable();
 c28:	78 94       	sei

    Grundstellung();    // alle C-Relais offen, alle L-Relais zu
 c2a:	0e df       	rcall	.-484    	; 0xa48 <Grundstellung>

    while (1)
    {
        readSerialCommand();
 c2c:	7d dc       	rcall	.-1798   	; 0x528 <readSerialCommand>
        switchRelais();
 c2e:	91 de       	rcall	.-734    	; 0x952 <switchRelais>
 c30:	fd cf       	rjmp	.-6      	; 0xc2c <tuner_main+0xb0>

00000c32 <fputc>:
 c32:	0f 93       	push	r16
 c34:	1f 93       	push	r17
 c36:	cf 93       	push	r28
 c38:	df 93       	push	r29
 c3a:	fb 01       	movw	r30, r22
 c3c:	23 81       	ldd	r18, Z+3	; 0x03
 c3e:	21 fd       	sbrc	r18, 1
 c40:	03 c0       	rjmp	.+6      	; 0xc48 <fputc+0x16>
 c42:	8f ef       	ldi	r24, 0xFF	; 255
 c44:	9f ef       	ldi	r25, 0xFF	; 255
 c46:	2c c0       	rjmp	.+88     	; 0xca0 <fputc+0x6e>
 c48:	22 ff       	sbrs	r18, 2
 c4a:	16 c0       	rjmp	.+44     	; 0xc78 <fputc+0x46>
 c4c:	46 81       	ldd	r20, Z+6	; 0x06
 c4e:	57 81       	ldd	r21, Z+7	; 0x07
 c50:	24 81       	ldd	r18, Z+4	; 0x04
 c52:	35 81       	ldd	r19, Z+5	; 0x05
 c54:	42 17       	cp	r20, r18
 c56:	53 07       	cpc	r21, r19
 c58:	44 f4       	brge	.+16     	; 0xc6a <fputc+0x38>
 c5a:	a0 81       	ld	r26, Z
 c5c:	b1 81       	ldd	r27, Z+1	; 0x01
 c5e:	9d 01       	movw	r18, r26
 c60:	2f 5f       	subi	r18, 0xFF	; 255
 c62:	3f 4f       	sbci	r19, 0xFF	; 255
 c64:	31 83       	std	Z+1, r19	; 0x01
 c66:	20 83       	st	Z, r18
 c68:	8c 93       	st	X, r24
 c6a:	26 81       	ldd	r18, Z+6	; 0x06
 c6c:	37 81       	ldd	r19, Z+7	; 0x07
 c6e:	2f 5f       	subi	r18, 0xFF	; 255
 c70:	3f 4f       	sbci	r19, 0xFF	; 255
 c72:	37 83       	std	Z+7, r19	; 0x07
 c74:	26 83       	std	Z+6, r18	; 0x06
 c76:	14 c0       	rjmp	.+40     	; 0xca0 <fputc+0x6e>
 c78:	8b 01       	movw	r16, r22
 c7a:	ec 01       	movw	r28, r24
 c7c:	fb 01       	movw	r30, r22
 c7e:	00 84       	ldd	r0, Z+8	; 0x08
 c80:	f1 85       	ldd	r31, Z+9	; 0x09
 c82:	e0 2d       	mov	r30, r0
 c84:	09 95       	icall
 c86:	89 2b       	or	r24, r25
 c88:	e1 f6       	brne	.-72     	; 0xc42 <fputc+0x10>
 c8a:	d8 01       	movw	r26, r16
 c8c:	16 96       	adiw	r26, 0x06	; 6
 c8e:	8d 91       	ld	r24, X+
 c90:	9c 91       	ld	r25, X
 c92:	17 97       	sbiw	r26, 0x07	; 7
 c94:	01 96       	adiw	r24, 0x01	; 1
 c96:	17 96       	adiw	r26, 0x07	; 7
 c98:	9c 93       	st	X, r25
 c9a:	8e 93       	st	-X, r24
 c9c:	16 97       	sbiw	r26, 0x06	; 6
 c9e:	ce 01       	movw	r24, r28
 ca0:	df 91       	pop	r29
 ca2:	cf 91       	pop	r28
 ca4:	1f 91       	pop	r17
 ca6:	0f 91       	pop	r16
 ca8:	08 95       	ret

00000caa <_exit>:
 caa:	f8 94       	cli

00000cac <__stop_program>:
 cac:	ff cf       	rjmp	.-2      	; 0xcac <__stop_program>
